var a,t;a=this,t=function(a){"use strict";const t=a=>typeof a,e="tinybase",s=",",n=t(""),i=(a,t="")=>a.join(t),o=(a,t)=>a.map(t),c=a=>a.length,r=a=>0==c(a),l=(a,t)=>a.filter(t),y=(a,t,e)=>a.slice(t,e),u=(a,...t)=>a.push(...t),d=Promise,w=JSON.parse,E=(a,t)=>a instanceof t,p=a=>null==a,f=(a,t,e)=>p(a)?e?.():t(a),m=a=>t(a)==n,v=async a=>d.all(a),T=(a,t)=>a?.has(t)??!1,h=a=>[...a?.values()??[]],A=(a,t)=>a?.delete(t),L=Object,S=L.keys,N=L.freeze,C=(a=[])=>L.fromEntries(a),O=(...a)=>L.assign({},...a),R=(a,t)=>(delete a[t],a),b=(a,t)=>o(L.entries(a),(([a,e])=>t(e,a))),g=a=>L.values(a),_=a=>c(S(a)),I=a=>(a=>E(a,L)&&a.constructor==L)(a)&&0==_(a),D=a=>new Map(a),$=a=>[...a?.keys()??[]],M=(a,t)=>a?.get(t),P=(a,t)=>o([...a?.entries()??[]],(([a,e])=>t(e,a))),F=(a,t,e)=>p(e)?(A(a,t),a):a?.set(t,e),j=(a,t,e,s=F)=>(b(t,((t,s)=>e(a,s,t))),((a,t)=>{((a,t)=>{a?.forEach(t)})(a,((a,e)=>t(e)))})(a,(e=>((a,t)=>!p(((a,t)=>f(a,(a=>a[t])))(a,t)))(t,e)?0:s(a,e))),a),x="_id",B=a=>`"${a.replace(/"/g,'""')}"`,k=a=>new Set(Array.isArray(a)||p(a)?a:[a]),q=(a,t)=>a?.add(t),W="SELECT*FROM",H="FROM pragma_table_",J="WHERE",U=(a,t)=>{const e=D(),n=(a,t)=>!p(M(M(e,a),t)),y=async(t,n,y,d,w)=>{const E=k();b(w??{},(a=>o(S(a),(a=>q(E,a)))));const p=h(E);if(r(p)&&T(e,t)&&d)return await a("DROP TABLE"+B(t)),void F(e,t);if(r(p)||T(e,t)){const s=M(e,t),i=k($(s));await v([...o(p,(async e=>{A(i,e)||(await a(`ALTER TABLE${B(t)}ADD${B(e)}`),F(s,e,""))})),...y?o(h(i),(async e=>{e!=n&&(await a(`ALTER TABLE${B(t)}DROP${B(e)}`),F(s,e))})):[]])}else await a(`CREATE TABLE${B(t)}(${B(n)} PRIMARY KEY ON CONFLICT REPLACE${i(o(p,(a=>s+B(a))))});`),F(e,t,D([[n,""],...o(p,(a=>[a,""]))]));if(r(p))T(e,t)&&await a("DELETE FROM"+B(t));else{const r=[],y=[],d=[],E=l($(M(e,t)),(a=>a!=n));b(w,((a,t)=>{var e;u(r,`(?${e=c(E),",?".repeat(e)})`),u(y,t,...o(E,(t=>a[t]))),u(d,t)})),await a("INSERT INTO"+B(t)+"("+B(n)+i(o(E,(a=>s+B(a))))+")VALUES"+i(r,s)+"ON CONFLICT("+B(n)+")DO UPDATE SET"+i(o(E,(a=>B(a)+"=excluded."+B(a))),s),y),await a("DELETE FROM"+B(t)+J+B(n)+"NOT IN("+V(d)+")",d)}};return[async()=>j(e,C(await v(o(await a("SELECT name "+H+"list WHERE schema='main'AND type='table'AND name IN("+V(t)+")",t),(async({name:t})=>[t,C(o(await a("SELECT name,type "+H+"info(?)",[t]),(({name:a,type:t})=>[a,t])))])))),((a,t,s)=>{return F(e,t,j((o=D,T(n=e,i=t)||F(n,i,o()),M(n,i)),s,((a,t,e)=>{e!=M(a,t)&&F(a,t,e)}),((a,t)=>F(a,t))));var n,i,o}),((a,t)=>F(e,t))),async(t,e)=>{const s=n(t,e)?await a(W+B(t)+J+B(e)+"=?",["_"]):[];return r(s)?null:R(s[0],e)},async(a,t,e,s)=>await y(a,t,!0,!0,{[e]:s}),async(t,e)=>n(t,e)?C(l(o(await a(W+B(t)),(a=>[a[e],R({...a},e)])),(([a,t])=>!p(a)&&!I(t)))):{},y]},V=a=>i(o(a,(()=>"?")),s),Y=(a,t,e,s,n)=>{let i,o,c,r=0,l=0,y=0;const d=[],w=async a=>(2!=r&&(r=1,await E.schedule((async()=>{await a(),r=0}))),E),E={load:async(e,s)=>await w((async()=>{try{a.setContent(await t())}catch{a.setContent([e,s])}})),startAutoLoad:async(e={},n={})=>(E.stopAutoLoad(),await E.load(e,n),y=1,c=s((async(e,s)=>await w((async()=>{if(s)a.setTransactionChanges(s());else try{a.setContent(e?.()??await t())}catch{}})))),E),stopAutoLoad:()=>(y&&(n(c),c=void 0,y=0),E),save:async t=>(1!=r&&(r=2,await E.schedule((async()=>{try{await e(a.getContent,t)}catch{}r=0}))),E),startAutoSave:async()=>(await E.stopAutoSave().save(),i=a.addDidFinishTransactionListener(((a,t)=>{const[e,s]=t();I(e)&&I(s)||E.save((()=>[e,s]))})),E),stopAutoSave:()=>(f(i,a.delListener),E),schedule:async(...a)=>(u(d,...a),await(async()=>{if(!l){for(l=1;!p((a=d,o=a.shift()));)try{await o()}catch{}l=0}var a})(),E),getStore:()=>a,destroy:()=>E.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return N(E)},z="store",K=(a,t,e,s,[n],i)=>{const[o,c,r]=U(t,i),l=Y(a,(async()=>(await o(),w((await c(n,x)??{})[z]))),(async a=>l.schedule(o,(async()=>{var t;await r(n,x,"_",{[z]:(t=a(),JSON.stringify(t,((a,t)=>{return E(t,Map)?(e=(a,[t,e])=>(a[t]=e,a),s={},[...t].reduce(e,s)):t;var e,s})))})}))),e,s);return l},G=(a,t,e,s,[n,i,[o,c,r]],y)=>{const[u,d,w,E,f]=U(t,y);return Y(a,(async()=>{await u();const a=await(async()=>C(l(await v(P(n,(async([a,t],e)=>[a,await E(e,t)]))),(a=>!I(a[1])))))(),t=await(async()=>o?await d(r,x):{})();return I(a)&&p(t)?void 0:[a,t]}),(async a=>{const[t,e]=a();await u(),await(async a=>await v(P(i,(async([t,e,s,n],i)=>await f(t,e,s,n,a[i])))))(t),await(async a=>c?await w(r,x,"_",a):null)(e)}),e,s)},Q="json",X="autoLoadIntervalSeconds",Z="rowIdColumnName",aa="tableId",ta="tableName",ea={mode:Q,[X]:1},sa={load:0,save:0,[ta]:e+"_values"},na=(a,t,e,s)=>{const n=D();return b(a,((a,i)=>{const o=y(g(O(t,m(a)?{[e]:a}:a)),0,_(t));p(o[0])||s(i,o[0])||F(n,i,o)})),n},ia="pragma ",oa="data_version",ca="schema_version",ra=(a,t,s,n,i)=>{let o,c;const[r,l,u,d]=(a=>{const t=(a=>O(ea,m(a)?{storeTableName:a}:a??{}))(a),s=t[X];if(t.mode==Q){const{storeTableName:a=e}=t;return[1,s,[a],k(a)]}const{tables:{load:n={},save:i={}}={},values:o={}}=t,c=y(g(O(sa,o)),0,_(sa)),r=c[2],l=k(r);return[0,s,[na(n,{[aa]:null,[Z]:x},aa,(a=>q(l,a)&&a==r)),na(i,{[ta]:null,[Z]:x,deleteEmptyColumns:0,deleteEmptyTable:0},ta,((a,t)=>q(l,t)&&t==r)),c],l]})(t);return(r?K:G)(a,s,(a=>[setInterval((async()=>{try{const t=(await s(ia+oa))[0][oa],e=(await s(ia+ca))[0][ca];t==(o??=t)&&e==(c??=e)||(a(),o=t,c=e)}catch{}}),1e3*l),n((t=>d.has(t)?a():0))]),(([a,t])=>{clearInterval(a),o=c=null,i(t)}),u,h(d))};a.createSqliteWasmPersister=(a,t,e,s)=>ra(a,s,(async(a,t=[])=>e.exec(a,{bind:t,rowMode:"object",returnValue:"resultRows"}).map((a=>({...a})))),(a=>t.capi.sqlite3_update_hook(e,((t,e,s,n)=>a(n)),0)),(()=>t.capi.sqlite3_update_hook(e,(()=>0),0)))},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((a="undefined"!=typeof globalThis?globalThis:a||self).TinyBasePersisterSqliteWasm={});
