var a,t;a=this,t=function(a){"use strict";const t=a=>typeof a,e="tinybase",s=",",n=t(""),i=(a,t="")=>a.join(t),o=(a,t)=>a.map(t),r=a=>a.length,c=a=>0==r(a),l=(a,t)=>a.filter(t),y=(a,t,e)=>a.slice(t,e),u=(a,...t)=>a.push(...t),d=Promise,w=JSON.parse,p=(a,t)=>a instanceof t,E=a=>null==a,m=(a,t,e)=>E(a)?e?.():t(a),v=a=>t(a)==n,f=async a=>d.all(a),h=Object,T=h.keys,A=h.freeze,L=(a=[])=>h.fromEntries(a),S=(...a)=>h.assign({},...a),b=(a,t)=>(delete a[t],a),R=(a,t)=>o(h.entries(a),(([a,e])=>t(e,a))),C=a=>h.values(a),N=a=>r(T(a)),_=a=>(a=>p(a,h)&&a.constructor==h)(a)&&0==N(a),g=(a,t)=>a?.has(t)??!1,O=a=>[...a?.values()??[]],I=(a,t)=>a?.delete(t),D=a=>new Map(a),$=(a,t)=>a?.get(t),M=(a,t)=>o([...a?.entries()??[]],(([a,e])=>t(e,a))),P=(a,t,e)=>E(e)?(I(a,t),a):a?.set(t,e),F=(a,t,e,s=P)=>(R(t,((t,s)=>e(a,s,t))),((a,t)=>{((a,t)=>{a?.forEach(t)})(a,((a,e)=>t(e)))})(a,(e=>((a,t)=>!E(((a,t)=>m(a,(a=>a[t])))(a,t)))(t,e)?0:s(a,e))),a),j="_id",q=a=>`"${a.replace(/"/g,'""')}"`,B=a=>new Set(Array.isArray(a)||E(a)?a:[a]),k="SELECT*FROM",x="FROM pragma_table_",W="WHERE",J=W+" schema='main'AND type='table'AND name!='sqlite_schema'",V=a=>{const t=D(),e=(a,e)=>!E($($(t,a),e)),n=async(e,n,l,y,d)=>{const w=B();R(d??{},(a=>o(T(a),(a=>{return t=w,e=a,t?.add(e);var t,e}))));const p=O(w);if(c(p)&&g(t,e)&&y)return await a("DROP TABLE"+q(e)),void P(t,e);if(c(p)||g(t,e)){const s=$(t,e),i=B((E=s,[...E?.keys()??[]]));await f([...o(p,(async t=>{I(i,t)||(await a(`ALTER TABLE${q(e)}ADD${q(t)}`),P(s,t,""))})),...l?o(O(i),(async t=>{t!=n&&(await a(`ALTER TABLE${q(e)}DROP${q(t)}`),P(s,t))})):[]])}else await a(`CREATE TABLE${q(e)}(${q(n)} PRIMARY KEY ON CONFLICT REPLACE${i(o(p,(a=>s+q(a))))});`),P(t,e,D([[n,""],...o(p,(a=>[a,""]))]));var E;if(c(p))await a("DELETE FROM"+q(e));else{const t=[],c=[],l=[];R(d,((a,e)=>{var s;u(t,`(?${s=r(p),",?".repeat(s)})`),u(c,e,...o(p,(t=>a[t]))),u(l,e)})),await a("INSERT INTO"+q(e)+"("+q(n)+i(o(p,(a=>s+q(a))))+")VALUES"+i(t,s),c),await a("DELETE FROM"+q(e)+W+q(n)+"NOT IN("+i(o(l,(()=>"?")),s)+")",l)}};return[async()=>F(t,L(await f(o(await a("SELECT name "+x+"list "+J),(async({name:t})=>[t,L(o(await a("SELECT name,type "+x+"info(?)",[t]),(({name:a,type:t})=>[a,t])))])))),((a,e,s)=>{return P(t,e,F((o=D,g(n=t,i=e)||P(n,i,o()),$(n,i)),s,((a,t,e)=>{e!=$(a,t)&&P(a,t,e)}),((a,t)=>P(a,t))));var n,i,o}),((a,e)=>P(t,e))),async(t,s)=>{const n=e(t,s)?await a(k+q(t)+W+q(s)+"=?",["_"]):[];return c(n)?null:b(n[0],s)},async(a,t,e,s)=>await n(a,t,!0,!0,{[e]:s}),async(t,s)=>e(t,s)?L(l(o(await a(k+q(t)),(a=>[a[s],b(a,s)])),(([a,t])=>!E(a)&&!_(t)))):{},n]},Y=(a,t,e,s,n)=>{let i,o,r,c=0,l=0,y=0;const d=[],w=async a=>{2!=c&&(c=1,await a(),c=0)},p={load:async(e,s)=>(await w((async()=>{try{a.setContent(await t())}catch{a.setContent([e,s])}})),p),startAutoLoad:async(e={},n={})=>(p.stopAutoLoad(),await p.load(e,n),y=1,r=s((async(e,s)=>{await w((async()=>{if(s)a.setTransactionChanges(s());else try{a.setContent(e?.()??await t())}catch{}}))})),p),stopAutoLoad:()=>(y&&(n(r),r=void 0,y=0),p),save:async t=>(await p.schedule((async()=>{if(1!=c){c=2;try{await e(a.getContent,t)}catch{}c=0}})),p),startAutoSave:async()=>(await p.stopAutoSave().save(),i=a.addDidFinishTransactionListener(((a,t)=>{const e=t();p.save((()=>e))})),p),stopAutoSave:()=>(m(i,a.delListener),p),schedule:async(...a)=>(u(d,...a),await(async()=>{if(!l){for(l=1;!E((a=d,o=a.shift()));)try{await o()}catch{}l=0}var a})(),p),getStore:()=>a,destroy:()=>p.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return A(p)},z="store",H=(a,t,s,n,{storeTableName:i=e})=>{const[o,r,c]=V(t),l=Y(a,(async()=>(await o(),w((await r(i,j)??{})[z]))),(async a=>l.schedule(o,(async()=>{var t;await c(i,j,"_",{[z]:(t=a(),JSON.stringify(t,((a,t)=>{return p(t,Map)?(e=(a,[t,e])=>(a[t]=e,a),s={},[...t].reduce(e,s)):t;var e,s})))})}))),s,n);return l},K="rowIdColumnName",U="tableId",G="tableName",Q={load:0,save:0,[G]:e+"_values"},X=(a,t,e,s)=>{const n=D();return R(a,((a,i)=>{const o=y(C(S(t,v(a)?{[e]:a}:a)),0,N(t));E(o[0])||s(i,o[0])||P(n,i,o)})),n},Z=(a,t,e,s,n)=>{const[i,o,[r,c,u]]=(({tables:{load:a={},save:t={}}={},values:e={}})=>{const s=y(C(S(Q,e)),0,N(Q)),n=s[2];return[X(a,{[U]:null,[K]:j},U,(a=>a==n)),X(t,{[G]:null,[K]:j,deleteEmptyColumns:0,deleteEmptyTable:0},G,((a,t)=>t==n)),s]})(n),[d,w,p,m,v]=V(t),h=Y(a,(async()=>{await d();const a=await(async()=>L(l(await f(M(i,(async([a,t],e)=>[a,await m(e,t)]))),(a=>!_(a[1])))))(),t=await(async()=>r?await w(u,j):{})();return _(a)&&E(t)?void 0:[a,t]}),(async a=>{const[t,e]=a();h.schedule(d,...(a=>M(o,(([t,e,s,n],i)=>async()=>await v(t,e,s,n,a[i]))))(t),(a=>c?async()=>await p(u,j,"_",a):null)(e))}),e,s);return h},aa="json",ta="autoLoadIntervalSeconds",ea={mode:aa,[ta]:1},sa="pragma ",na="data_version",ia="schema_version",oa=(a,t,e,s,n)=>{const i=S(ea,v(t)?{storeTableName:t}:t??{});let o,r;return(i.mode==aa?H:Z)(a,e,(a=>[setInterval((async()=>{try{const t=(await e(sa+na))[0][na],s=(await e(sa+ia))[0][ia];t==(o??=t)&&s==(r??=s)||(a(),o=t,r=s)}catch{}}),1e3*i[ta]),s(a)]),(([a,t])=>{clearInterval(a),o=r=null,n(t)}),i)};a.createSqliteWasmPersister=(a,t,e,s)=>oa(a,s,(async(a,t=[])=>e.exec(a,{bind:t,rowMode:"object",returnValue:"resultRows"}).map((a=>({...a})))),(a=>t.capi.sqlite3_update_hook(e,(()=>a()),0)),(()=>t.capi.sqlite3_update_hook(e,(()=>0),0)))},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((a="undefined"!=typeof globalThis?globalThis:a||self).TinyBasePersisterSqliteWasm={});
