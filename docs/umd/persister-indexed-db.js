var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,a=t(""),s=Promise,n=clearInterval,o=e=>null==e,r=(e,t,a)=>o(e)?a?.():t(e),c=e=>new s(e),i=async e=>s.all(e),d=(e,t)=>e.map(t),l=(e,...t)=>e.push(...t),y=Object,u=e=>y.getPrototypeOf(e),g=y.entries,p=y.keys,w=y.freeze,h=e=>(e=>!o(e)&&r(u(e),(e=>e==y.prototype||o(u(e))),(()=>!0)))(e)&&0==(e=>p(e).length)(e),v=e=>new Map(e),f=(e,t)=>e?.get(t),b=(e,t,a)=>{return o(a)?(s=e,n=t,s?.delete(n),e):e?.set(t,a);var s,n},A=(e,t,a,s)=>{var n,o;return n=e,o=t,n?.has(o)?s?.(f(e,t)):b(e,t,a()),f(e,t)},S=v(),C=v(),x=globalThis.window,D=["t","v"],L={keyPath:"k"},M=async(e,t)=>{const a=((t,a)=>d(g(t),(([t,a])=>T(e,"put",{k:t,v:a}))))(t);d(await T(e,"getAllKeys"),(s=>((e,t)=>t in e)(t,s)?0:l(a,T(e,"delete",s)))),await i(a)},T=async(e,t,a)=>c(((s,n)=>{const o=e[t](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,s,u=1,g)=>{const p=async(e,t=[],a=0)=>c(((n,o)=>{const r=(x?x.indexedDB:indexedDB).open(s,a?2:void 0);r.onupgradeneeded=()=>a&&d(D,(e=>{try{r.result.createObjectStore(e,L)}catch{}})),r.onsuccess=async()=>{try{const a=r.result.transaction(D,"readwrite"),s=await i(d(D,(async(s,n)=>await e(a.objectStore(s),t[n]))));r.result.close(),n(s)}catch(e){r.result.close(),o(e)}},r.onerror=()=>o("indexedDB.open error")}));return((e,s,n,c,i,d,y,u={},g=[])=>{let p,v,x,D=0;A(S,g,(()=>0)),A(C,g,(()=>[]));const[L,M,T,j]=((e,t)=>!e||o(t.getMergeableContent)?[0,t.getContent,t.getTransactionChanges,([e,t])=>!h(e)||!h(t)]:[1,t.getMergeableContent,t.getTransactionMergeableChanges,([,[[,e],[,t]]])=>!h(e)||!h(t)])(y,e),m=async e=>(2!=D&&(D=1,await P.schedule((async()=>{await e(),D=0}))),P),k=s=>{var n;(L&&(n=s?.[0],t(n)==a)?1===s?.[1][2]?e.applyMergeableChanges:e.setMergeableContent:1===s?.[2]?e.applyChanges:e.setContent)(s)},P={load:async(t,a)=>await m((async()=>{try{k(await s())}catch(s){d?.(s),e.setContent([t,a])}})),startAutoLoad:async(e={},t={})=>(await P.stopAutoLoad().load(e,t),v=c((async(e,t)=>{const a=t?.();await m((async()=>{try{k(a??e?.()??await s())}catch(e){d?.(e)}}))})),P),stopAutoLoad:()=>(v&&(i(v),v=void 0),P),isAutoLoading:()=>!o(v),save:async e=>(1!=D&&(D=2,await P.schedule((async()=>{try{await n(M,e)}catch(e){d?.(e)}D=0}))),P),startAutoSave:async()=>(await P.stopAutoSave().save(),x=e.addDidFinishTransactionListener((()=>{const e=T();j(e)&&P.save((()=>e))})),P),stopAutoSave:()=>(r(x,e.delListener),x=void 0,P),isAutoSaving:()=>!o(x),schedule:async(...e)=>(l(f(C,g),...e),await(async()=>{if(!f(S,g)){for(b(S,g,1);!o((e=f(C,g),p=e.shift()));)try{await p()}catch(e){d?.(e)}b(S,g,0)}var e})(),P),getStore:()=>e,destroy:()=>P.stopAutoLoad().stopAutoSave(),getStats:()=>({}),...u};return w(P)})(e,(async()=>await p((async e=>((e=[])=>y.fromEntries(e))(d(await T(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await p((async(e,t)=>await M(e,t)),e(),1)),(e=>setInterval(e,1e3*u)),(e=>n(e)),g,!1,{getDbName:()=>s})},e.objectStoreMatch=M},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
