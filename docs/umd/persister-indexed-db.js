var e,t;e=this,t=function(e){"use strict";const t=Promise,a=clearInterval,s=e=>null==e,n=(e,t,a)=>s(e)?a?.():t(e),o=e=>new t(e),r=async e=>t.all(e),c=(e,t)=>e.map(t),i=(e,...t)=>e.push(...t),d=Object,l=e=>d.getPrototypeOf(e),y=d.entries,u=d.keys,g=d.freeze,p=e=>(e=>!s(e)&&n(l(e),(e=>e==d.prototype||s(l(e))),(()=>!0)))(e)&&0==(e=>u(e).length)(e),w=e=>new Map(e),h=(e,t)=>e?.get(t),v=(e,t,a)=>{return s(a)?(n=e,o=t,n?.delete(o),e):e?.set(t,a);var n,o},f=(e,t,a,s)=>{var n,o;return n=e,o=t,n?.has(o)?s?.(h(e,t)):v(e,t,a()),h(e,t)},b=w(),A=w(),C=globalThis.window,S=["t","v"],x={keyPath:"k"},D=async(e,t)=>{const a=((t,a)=>c(y(t),(([t,a])=>L(e,"put",{k:t,v:a}))))(t);c(await L(e,"getAllKeys"),(s=>((e,t)=>t in e)(t,s)?0:i(a,L(e,"delete",s)))),await r(a)},L=async(e,t,a)=>o(((s,n)=>{const o=e[t](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,t,l=1,y)=>{const u=async(e,a=[],s=0)=>o(((n,o)=>{const i=(C?C.indexedDB:indexedDB).open(t,s?2:void 0);i.onupgradeneeded=()=>s&&c(S,(e=>{try{i.result.createObjectStore(e,x)}catch{}})),i.onsuccess=async()=>{try{const t=i.result.transaction(S,"readwrite"),s=await r(c(S,(async(s,n)=>await e(t.objectStore(s),a[n]))));i.result.close(),n(s)}catch(e){i.result.close(),o(e)}},i.onerror=()=>o("indexedDB.open error")}));return((e,t,a,o,r,c,d,l={},y=[])=>{let u,w,C,S=0;f(b,y,(()=>0)),f(A,y,(()=>[]));const[x,D,L,M,T]=((e,t)=>!e||s(t.getMergeableContent)?[0,t.getContent,t.getTransactionChanges,([e,t])=>!p(e)||!p(t),t.setContent]:[1,t.getMergeableContent,t.getTransactionMergeableChanges,([[e],[t]])=>!p(e)||!p(t),t.setDefaultContent])(d,e),j=async e=>(2!=S&&(S=1,await k.schedule((async()=>{await e(),S=0}))),k),m=t=>{var a;(x&&(a=t?.[0],Array.isArray(a))?1===t?.[2]?e.applyMergeableChanges:e.setMergeableContent:1===t?.[2]?e.applyChanges:e.setContent)(t)},k={load:async e=>await j((async()=>{try{m(await t())}catch(t){c?.(t),e&&T(e)}})),startAutoLoad:async e=>(await k.stopAutoLoad().load(e),w=o((async(e,a)=>{const s=a?.();await j((async()=>{try{m(s??e?.()??await t())}catch(e){c?.(e)}}))})),k),stopAutoLoad:()=>(w&&(r(w),w=void 0),k),isAutoLoading:()=>!s(w),save:async e=>(1!=S&&(S=2,await k.schedule((async()=>{try{await a(D,e)}catch(e){c?.(e)}S=0}))),k),startAutoSave:async()=>(await k.stopAutoSave().save(),C=e.addDidFinishTransactionListener((()=>{const e=L();M(e)&&k.save((()=>e))})),k),stopAutoSave:()=>(n(C,e.delListener),C=void 0,k),isAutoSaving:()=>!s(C),schedule:async(...e)=>(i(h(A,y),...e),await(async()=>{if(!h(b,y)){for(v(b,y,1);!s((e=h(A,y),u=e.shift()));)try{await u()}catch(e){c?.(e)}v(b,y,0)}var e})(),k),getStore:()=>e,destroy:()=>k.stopAutoLoad().stopAutoSave(),getStats:()=>({}),...l};return g(k)})(e,(async()=>await u((async e=>((e=[])=>d.fromEntries(e))(c(await L(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await u((async(e,t)=>await D(e,t)),e(),1)),(e=>setInterval(e,1e3*l)),(e=>a(e)),y,!1,{getDbName:()=>t})},e.objectStoreMatch=D},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
