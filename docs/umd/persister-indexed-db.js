var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,a=t(""),n=Promise,s=clearInterval,o=e=>null==e,r=(e,t,a)=>o(e)?a?.():t(e),c=e=>new n(e),i=async e=>n.all(e),l=(e,t)=>e.map(t),d=(e,...t)=>e.push(...t),y=Object,u=e=>y.getPrototypeOf(e),p=y.entries,g=y.keys,w=y.freeze,h=e=>(e=>!o(e)&&r(u(e),(e=>e==y.prototype||o(u(e))),(()=>!0)))(e)&&0==(e=>g(e).length)(e),f=e=>new Map(e),v=(e,t)=>e?.get(t),b=(e,t,a)=>{return o(a)?(n=e,s=t,n?.delete(s),e):e?.set(t,a);var n,s},C=(e,t,a,n)=>{var s,o;return s=e,o=t,s?.has(o)?n?.(v(e,t)):b(e,t,a()),v(e,t)},A=f(),S=f(),x=e=>{return n=e?.[0],t(n)==a;var n},M=globalThis.window,D=["t","v"],T={keyPath:"k"},j=async(e,t)=>{const a=((t,a)=>l(p(t),(([t,a])=>m(e,"put",{k:t,v:a}))))(t);l(await m(e,"getAllKeys"),(n=>((e,t)=>t in e)(t,n)?0:d(a,m(e,"delete",n)))),await i(a)},m=async(e,t,a)=>c(((n,s)=>{const o=e[t](a);o.onsuccess=()=>n(o.result),o.onerror=()=>s(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,t,a=1,n)=>{const u=async(e,a=[],n=0)=>c(((s,o)=>{const r=(M?M.indexedDB:indexedDB).open(t,n?2:void 0);r.onupgradeneeded=()=>n&&l(D,(e=>{try{r.result.createObjectStore(e,T)}catch{}})),r.onsuccess=async()=>{try{const t=r.result.transaction(D,"readwrite"),n=await i(l(D,(async(n,s)=>await e(t.objectStore(n),a[s]))));r.result.close(),s(n)}catch(e){r.result.close(),o(e)}},r.onerror=()=>o("indexedDB.open error")}));return((e,t,a,n,s,c,i,[l,y]=[],u=[])=>{let p,g,f,M=0,D=0;C(A,u,(()=>0)),C(S,u,(()=>[]));const[T,j,m,L]=((e,t)=>!e||o(t.getMergeableContent)?[0,t.getContent,t.getTransactionChanges,([e,t])=>!h(e)||!h(t)]:[1,t.getMergeableContent,t.getTransactionMergeableChanges,([,[[,e],[,t]]])=>!h(e)||!h(t)])(i,e),k=async e=>(2!=M&&(M=1,await P.schedule((async()=>{await e(),M=0}))),P),P={load:async(a,n)=>await k((async()=>{try{const a=await t();(T&&x(a)?e.setMergeableContent:e.setContent)(a)}catch{e.setContent([a,n])}})),startAutoLoad:async(a={},s={})=>(P.stopAutoLoad(),await P.load(a,s),D=1,f=n((async(a,n)=>{if(n){const t=n();await k((async()=>(T&&x(t)?e.applyMergeableChanges:e.applyChanges)(t)))}else await k((async()=>{try{const n=a?.()??await t();(T&&x(n)?e.setMergeableContent:e.setContent)(n)}catch(e){c?.(e)}}))})),P),stopAutoLoad:()=>(D&&(s(f),f=void 0,D=0),P),save:async e=>(1!=M&&(M=2,await P.schedule((async()=>{try{await a(j,e)}catch(e){c?.(e)}M=0}))),P),startAutoSave:async()=>(await P.stopAutoSave().save(),p=e.addDidFinishTransactionListener((()=>{const e=m();L(e)&&P.save((()=>e))})),P),stopAutoSave:()=>(r(p,e.delListener),p=void 0,P),schedule:async(...e)=>(d(v(S,u),...e),await(async()=>{if(!v(A,u)){for(b(A,u,1);!o((e=v(S,u),g=e.shift()));)try{await g()}catch(e){c?.(e)}b(A,u,0)}var e})(),P),getStore:()=>e,destroy:()=>P.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return l&&(P[l]=()=>y),w(P)})(e,(async()=>await u((async e=>((e=[])=>y.fromEntries(e))(l(await m(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await u((async(e,t)=>await j(e,t)),e(),1)),(e=>setInterval(e,1e3*a)),(e=>s(e)),n,!1,["getDbName",t])},e.objectStoreMatch=j},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
