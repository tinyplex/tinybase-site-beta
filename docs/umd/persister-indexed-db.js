var t,e;t=this,e=function(t){"use strict";const e=Promise,a=setInterval,s=clearInterval,n=t=>null==t,o=(t,e,a)=>n(t)?a?.():e(t),c=t=>new e(t),r=async t=>e.all(t),i=(t,e)=>t.map(e),d=(t,...e)=>t.push(...e),y=Object,l=y.keys,u=y.freeze,w=t=>(t=>t instanceof y&&t.constructor==y)(t)&&0==(t=>l(t).length)(t),h=t=>new Map(t),p=(t,e)=>t?.get(e),f=(t,e,a)=>{return n(a)?(s=t,o=e,s?.delete(o),t):t?.set(e,a);var s,o},v=(t,e,a)=>{var s,n;return s=t,n=e,s?.has(n)||f(t,e,a()),p(t,e)},g=h(),b=h(),A=globalThis.window,S=["t","v"],x={keyPath:"k"},j=async(t,e)=>{const a=((e,a)=>i(y.entries(e),(([e,a])=>m(t,"put",{k:e,v:a}))))(e);i(await m(t,"getAllKeys"),(s=>((t,e)=>!n(((t,e)=>o(t,(t=>t[e])))(t,e)))(e,s)?0:d(a,m(t,"delete",s)))),await r(a)},m=async(t,e,a)=>c(((s,n)=>{const o=t[e](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${e} error`)}));t.createIndexedDbPersister=(t,e,l=1,h)=>{const D=async(t,a=[],s=0)=>c(((n,o)=>{const c=A.indexedDB.open(e,s?2:void 0);c.onupgradeneeded=()=>s&&i(S,(t=>{try{c.result.createObjectStore(t,x)}catch{}})),c.onsuccess=async()=>{try{const e=c.result.transaction(S,"readwrite"),s=await r(i(S,(async(s,n)=>await t(e.objectStore(s),a[n]))));c.result.close(),n(s)}catch(t){o(t)}},c.onerror=()=>o("indexedDB.open error")}));return((t,e,a,s,c,r,[i,y]=[],l=[])=>{let h,A,S,x=0,j=0;v(g,l,(()=>0)),v(b,l,(()=>[]));const m=async t=>(2!=x&&(x=1,await D.schedule((async()=>{await t(),x=0}))),D),D={load:async(a,s)=>await m((async()=>{try{t.setContent(await e())}catch{t.setContent([a,s])}})),startAutoLoad:async(a={},n={})=>(D.stopAutoLoad(),await D.load(a,n),j=1,S=s((async(a,s)=>{if(s){const e=s();await m((async()=>t.setTransactionChanges(e)))}else await m((async()=>{try{t.setContent(a?.()??await e())}catch(t){r?.(t)}}))})),D),stopAutoLoad:()=>(j&&(c(S),S=void 0,j=0),D),save:async e=>(1!=x&&(x=2,await D.schedule((async()=>{try{await a(t.getContent,e)}catch(t){r?.(t)}x=0}))),D),startAutoSave:async()=>(await D.stopAutoSave().save(),h=t.addDidFinishTransactionListener(((t,e)=>{const[a,s]=e();w(a)&&w(s)||D.save((()=>[a,s]))})),D),stopAutoSave:()=>(o(h,t.delListener),h=void 0,D),schedule:async(...t)=>(d(p(b,l),...t),await(async()=>{if(!p(g,l)){for(f(g,l,1);!n((t=p(b,l),A=t.shift()));)try{await A()}catch(t){r?.(t)}f(g,l,0)}var t})(),D),getStore:()=>t,destroy:()=>D.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return i&&(D[i]=()=>y),u(D)})(t,(async()=>await D((async t=>((t=[])=>y.fromEntries(t))(i(await m(t,"getAll"),(({k:t,v:e})=>[t,e])))))),(async t=>await D((async(t,e)=>await j(t,e)),t(),1)),(t=>a(t,1e3*l)),(t=>s(t)),h,["getDbName",e])},t.objectStoreMatch=j},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterIndexedDb={});
