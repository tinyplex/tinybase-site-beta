var e,l;e=this,l=function(e){"use strict";const l=e=>typeof e,t="",a=l(t),o=l(!0),n=l(0),d="type",r="default",s=(e,l)=>e.every(l),$=(e,l)=>e.sort(l),i=(e,l)=>e.forEach(l),I=(e,l)=>e.map(l),c=e=>e.length,b=e=>0==c(e),w=(e,...l)=>e.push(...l),C=e=>e.pop(),h=(e,...l)=>e.unshift(...l),u=e=>e.shift(),g=JSON.parse,T=isFinite,f=e=>null==e,R=e=>e==a||e==o,p=e=>l(e)==a,m=e=>Array.isArray(e),y=(e,l)=>e?.has(l)??!1,L=e=>[...e?.values()??[]],v=(e,l)=>e?.forEach(l),S=(e,l)=>e?.delete(l),k=e=>new Map(e),E=(e,l)=>e?.get(l),j=(e,l)=>v(e,((e,t)=>l(t,e))),x=(e,l)=>I([...e?.entries()??[]],(([e,t])=>l(t,e))),A=(e,l,t)=>f(t)?(S(e,l),e):e?.set(l,t),J=(e,l,t)=>(y(e,l)||A(e,l,t()),E(e,l)),O=e=>new Set(m(e)||f(e)?e:[e]),N=(e,l)=>e?.add(l),z=e=>[e,e],D=()=>[k(),k()],F=/[^A-Za-z0-9]+/,G=/^( *)\/\*\* *(.*?) *\*\/$/gm,M=(e,l,t)=>e.substring(l,t),W=e=>e.toUpperCase(),P=e=>e.toLowerCase(),_=(e,l,t,a=1)=>{const o=`${l}${1==a?"":a}`;return y(e,o)?_(e,l,t,a+1):(A(e,o,t),o)},B=e=>e.replace(G,((e,l,t)=>{const a=77-Q(l);return`${l}/**\n${t.replace(RegExp(`([^\\n]{1,${a}})(\\s|$)`,"g"),l+" * $1\n")}${l} */`})),Q=e=>e.length,U=(e,l=t)=>e.join(l),Z=e=>e.flat(1e3),q=(e,l=0)=>U(I(e.split(F),((e,t)=>(t>0||l?W:P)(M(e,0,1))+M(e,1)))),H=e=>W(U(e.split(F),"_")),K=e=>`/** ${e}. */`,V=()=>{const e=D(),l=k(),a=k(),o=k();return[(...e)=>U(Z(e),"\n"),(l,t,...a)=>i(a,(a=>N(J(e[l],t,O),a))),(e,t="",a="")=>_(l,e,[t,a]),(e,l,t,o,n,d="")=>_(a,e,[l,t,o,n,d]),(e,l,t)=>_(o,e,m(t)?[`(${l}) => {`,t,"}"]:[`(${l}) => ${t}`]),(e,l)=>E(o,e)===l?e:_(o,e,l),l=>[...$(x(e[l],((e,l)=>`import {${U($(L(e)),", ")}} from '${l}';`))),t],()=>x(l,(([e,l],a)=>[K(l),`export type ${a} = ${e};`,t])),e=>x(a,(([l,a,o,n,d],r)=>{const s=e?[`${r}: ${d}(${l}): ${a} => ${o},`]:[`${r}${d}(${l}): ${a};`];return e||h(s,K(n)),w(s,t),s})),()=>x(o,((e,l)=>(e=m(e)?e:[e],w(e,C(e)+";"),[`const ${l} = ${u(e)}`,e,t])))]},X=Object,Y=X.keys,ee=X.freeze,le=(e,l)=>I(X.entries(e),(([e,t])=>l(t,e))),te=e=>b(Y(e)),ae=e=>{const t=l(e);return R(t)||t==n&&T(e)?t:void 0},oe="the content of",ne="the Store",de="A function for",re="export",se="listener",$e=" | undefined",ie=`Registers a ${se} that will be called`,Ie="Represents",ce=" => void",be=`${oe} ${ne}`,we="the end of the transaction",Ce="the specified Row",he=(e,l=0)=>`${Ie} a Row when ${l?"s":"g"}etting ${oe} the '${e}' Table`,ue=(e,l,t=0)=>`Gets ${t?"sorted, paginated":"the"} Ids of the ${e}s in ${l}`,ge=(e,l)=>`Calls a function for each ${e} in ${l}`,Te=(e,l=ne)=>`Gets whether ${e} exists in ${l}`,fe=e=>"A function that takes "+e,Re=(e=0,l=0)=>`${de} listening to changes to ${xe[e]} in ${xe[l]}`,pe=(e,l,t=0)=>`${ie} whenever ${e} in ${l} change`+(t?"":"s"),me=(e=0)=>`${je[e]} ${be}`,ye=e=>`the '${e}' Table`,Le=e=>`${Ce} in ${ye(e)}`,ve=e=>`the '${e}' Cell`,Se=(e,l=0)=>`${je[l]} ${oe} ${ye(e)}`,ke=(e,l=0)=>`${je[l]} ${oe} ${Le(e)}`,Ee=(e,l,t=0)=>`${je[t]} ${ve(l)} for ${Le(e)}`,je=["Gets","Sets","Sets part of","Deletes"],xe=[ne,"anything","Table Ids","a Table","Row Ids","a Row","Cell Ids","a Cell","invalid Cell changes"],Ae=["ChangedCells","Id","IdOrNull","Ids","InvalidCells","Json","Store"],Je=(e,l=t,a=t)=>`store.${e}(${l})${a?" as "+a:t}`,Oe=(e,l=t)=>`fluent(() => ${Je(e,l)})`,Ne=(e,l=t,a=t)=>`store.${e}(${l?l+", ":t}proxy(${se})${a?", "+a:t})`,ze=(e,l)=>{if(te(e))return z(t);const[a,n,s,$,i,I,c,b,w,C]=V(),h=`./${q(l)}.d`,u=q(l,1),g=q(u),T=k(),R=l=>le(e,((e,a)=>l(a,J(T,a,(()=>{const e=q(a,1);return[s(e+"Table",`{[rowId: Id]: ${e}Row}`,`${Ie} the '${a}' Table`),s(e+"Row",`{${U(m(a,((e,l,a)=>`'${e}'${f(a)?"?":t}: ${l};`))," ")}}`,he(a)),s(e+"RowWhenSet",`{${U(m(a,((e,l)=>`'${e}'?: ${l};`))," ")}}`,he(a,1)),s(e+"CellId",U(m(a,(e=>`'${e}'`))," | "),`A Cell Id for the '${a}' Table`),s(e+"CellCallback",`(...[cellId, cell]: ${U(m(a,((e,l)=>`[cellId: '${e}', cell: ${l}]`))," | ")})${ce}`,fe(`a Cell Id and value from a Row in the '${a}' Table`)),s(e+"RowCallback",`(rowId: Id, forEachCell: (cellCallback: ${e}CellCallback)${ce})${ce}`,fe(`a Row Id from the '${a}' Table, and a Cell iterator`))]})),q(a,1),I(H(a),`'${a}'`)))),m=(l,t)=>le(e[l],((e,l)=>t(l,e[d],e[r],I(H(l),`'${l}'`),q(l,1)))),y=s("Tables",`{${U(R(((e,l)=>`'${e}'?: ${l[0]};`))," ")}}`,`${Ie} ${be}`),v=s("TableId",U(R((e=>`'${e}'`))," | "),"A Table Id in "+ne),S=s("TableCallback",`(...[tableId, rowCallback]: ${U(R(((e,l)=>`[tableId: '${e}', forEachRow: (rowCallback: ${l[5]})${ce}]`))," | ")})${ce}`,fe("a Table Id, and a Row iterator")),E=s("GetCellChange",`(...[tableId, rowId, cellId]: ${U(R(((e,l)=>`[tableId: '${e}', rowId: Id, cellId: ${l[3]}]`))," | ")}) => CellChange`,de+" returning information about any Cell's changes during  a transaction"),x=s("TablesListener",`(${g}: ${u}, getCellChange: ${E}${$e})${ce}`,Re(1)),O=s("TableIdsListener",`(${g}: ${u})${ce}`,Re(2)),N=s("TableListener",`(${g}: ${u}, tableId: ${v}, getCellChange: ${E}${$e})${ce}`,Re(3)),D=s("RowIdsListener",`(${g}: ${u}, tableId: ${v})${ce}`,Re(4,3)),F=s("RowListener",`(${g}: ${u}, tableId: ${v}, rowId: Id, getCellChange: ${E}${$e})${ce}`,Re(5,3)),G=s("CellIdsListener",`(${g}: ${u}, tableId: ${v}, rowId: Id)`+ce,Re(6,5)),M=s("CellListener",`(...[${g}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${U(Z(R((e=>m(e,((l,t)=>`[${g}: ${u}, tableId: '${e}', rowId: Id, cellId: '${l}', newCell: ${t}${$e}, oldCell: ${t}${$e}, getCellChange: ${E} | undefined]`)))))," | ")})${ce}`,Re(7,5)),W=s("InvalidCellListener",`(${g}: ${u}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${ce};`,Re(8)),P=s("TransactionListener",`(${g}: ${u}, cellsTouched: boolean)${ce};`,de+" listening to the completion of a transaction");$("hasTables",t,o,Je("hasTables"),Te("any Table")),$("getTables",t,y,Je("getTables"),me()),$("setTables","tables: "+y,u,Oe("setTables","tables"),me(1)),$("delTables",t,u,Oe("delTables"),me(3)),$("getTableIds",t,v+"[]",Je("getTableIds",t,v+"[]"),ue("Table",ne)),$("forEachTable","tableCallback: "+S,"void",Je("forEachTable","tableCallback as any"),ge("Table",ne));const _=k();return R(((e,[l,a,d,r,s,i],I,c)=>{n(1,h,l,a,d,r,s,i),$(`has${I}Table`,t,o,Je("hasTable",c),Te(ye(e))),$(`get${I}Table`,t,l,Je("getTable",c,l),Se(e)),$(`set${I}Table`,"table: "+l,u,Oe("setTable",c+", table"),Se(e,1)),$(`del${I}Table`,t,u,Oe("delTable",c),Se(e,3)),$(`get${I}RowIds`,t,"Ids",Je("getRowIds",c),ue("Row",ye(e))),$(`get${I}SortedRowIds`,`cellId?: ${r}, descending?: boolean, offset?: number, limit?: number`,"Ids",Je("getSortedRowIds",c+", cellId, descending, offset, limit"),ue("Row",ye(e),1)),$(`forEach${I}Row`,"rowCallback: "+i,"void",Je("forEachRow",c+", rowCallback as any"),ge("Row",ye(e))),$(`has${I}Row`,"rowId: Id",o,Je("hasRow",c+", rowId"),Te(Ce,ye(e))),$(`get${I}Row`,"rowId: Id",a,Je("getRow",c+", rowId",a),ke(e)),$(`set${I}Row`,"rowId: Id, row: "+d,u,Oe("setRow",c+", rowId, row"),ke(e,1)),$(`add${I}Row`,"row: "+d,"Id"+$e,Je("addRow",c+", row"),"Adds a new Row to "+ye(e)),$(`set${I}PartialRow`,"rowId: Id, partialRow: "+d,u,Oe("setPartialRow",c+", rowId, partialRow"),ke(e,2)),$(`del${I}Row`,"rowId: Id",u,Oe("delRow",c+", rowId"),ke(e,3)),$(`get${I}CellIds`,"rowId: Id",r+"[]",Je("getCellIds",c+", rowId",r+"[]"),ue("Cell",Le(e))),$(`forEach${I}Cell`,"rowId: Id, cellCallback: "+s,"void",Je("forEachCell",c+", rowId, cellCallback as any"),ge("Cell",Le(e))),m(e,((l,a,n,d,r)=>{const s="Map"+q(a,1);A(_,a,s),$(`has${I}${r}Cell`,"rowId: Id",o,Je("hasCell",`${c}, rowId, ${d}`),Te(ve(l),Le(e)));const i=`${a}${f(n)?$e:t}`;$(`get${I}${r}Cell`,"rowId: Id",i,Je("getCell",`${c}, rowId, ${d}`,i),Ee(e,l)),$(`set${I}${r}Cell`,`rowId: Id, cell: ${a} | ${s}`,u,Oe("setCell",`${c}, rowId, ${d}, cell as any`),Ee(e,l,1)),$(`del${I}${r}Cell`,"rowId: Id",u,Oe("delCell",`${c}, rowId, ${d}`),Ee(e,l,3))}))})),$("getJson",t,"Json",Je("getJson"),`${je[0]} a string serialization ${be}`),$("setJson","json: Json",u,Oe("setJson","json"),`${je[1]} ${be} from a serialized string`),$("transaction","actions: () => Return, doRollback?: (changedCells: ChangedCells, invalidCells: InvalidCells) => boolean","Return",Je("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),$("startTransaction",t,u,Oe("startTransaction"),"Explicitly starts a transaction"),$("finishTransaction","doRollback?: (changedCells: ChangedCells, invalidCells: InvalidCells) => boolean,",u,Oe("finishTransaction","doRollback"),"Explicitly finishes a transaction"),$("addTablesListener",`${se}: ${x}, mutator?: boolean`,"Id",Ne("addTablesListener",t,"mutator"),`${ie} whenever ${be} changes`),$("addTableIdsListener",`${se}: ${O}, mutator?: boolean`,"Id",Ne("addTableIdsListener",t,"mutator"),pe("the Table Ids",ne,1)),$("addTableListener",`tableId: ${v} | null, ${se}: ${N}, mutator?: boolean`,"Id",Ne("addTableListener","tableId","mutator"),pe("a Table",ne)),$("addRowIdsListener",`tableId: ${v} | null, ${se}: ${D}, mutator?: boolean`,"Id",Ne("addRowIdsListener","tableId","mutator"),pe("the Row Ids","a Table",1)),$("addRowListener",`tableId: ${v} | null, rowId: IdOrNull, ${se}: ${F}, mutator?: boolean`,"Id",Ne("addRowListener","tableId, rowId","mutator"),pe("a Row","a Table")),$("addCellIdsListener",`tableId: ${v} | null, rowId: IdOrNull, ${se}: ${G}, mutator?: boolean`,"Id",Ne("addCellIdsListener","tableId, rowId","mutator"),pe("the Cell Ids","a Row",1)),$("addCellListener",`tableId: ${v} | null, rowId: IdOrNull, cellId: ${U(R(((e,l)=>l[3]))," | ")} | null, ${se}: ${M}, mutator?: boolean`,"Id",Ne("addCellListener","tableId, rowId, cellId","mutator"),pe("a Cell","a Row")),$("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${se}: ${W}, mutator?: boolean`,"Id",Ne("addCellListener","tableId, rowId, cellId","mutator"),ie+" whenever an invalid Cell change was attempted"),$("addWillFinishTransactionListener",`${se}: ${P}`,"Id",Ne("addWillFinishTransactionListener"),`${ie} just before ${we}`),$("addDidFinishTransactionListener",`${se}: ${P}`,"Id",Ne("addDidFinishTransactionListener"),`${ie} just after ${we}`),$("callListener",se+"Id: Id",u,Oe("callListener",se+"Id"),`Manually provoke a ${se} to be called`),$("delListener",se+"Id: Id",u,Oe("delListener",se+"Id"),`Remove a ${se} that was previously added to ${ne}`),$("getStore",t,"Store","store",je[0]+" the underlying Store object"),j(_,((e,l)=>s(l,`(cell: ${e}${$e}) => ${e}`,`Takes a ${e} Cell value and returns another`))),n(0,"tinybase","CellChange",...Ae),n(1,"tinybase","createStore",...Ae),n(1,h,u,`create${u} as create${u}Decl`,y,v,S,x,O,N,D,F,G,M,W,P,...L(_)),I("store",["createStore().setSchema({",Z(R(((e,l,a,o)=>[`[${o}]: {`,...m(e,((e,l,a,o)=>`[${o}]: {[${I(H(d),`'${d}'`)}]: ${I(H(l),`'${l}'`)}${f(a)?t:`, [${I(H(r),`'${r}'`)}]: ${p(a)?I(H(a),`'${a}'`):a}`}},`)),"},"]))),"})"]),i("fluent","actions: () => Store",["actions();",`return ${g};`]),i("proxy",se+": any",`(_: Store, ...args: any[]) => ${se}(${g}, ...args)`),I(g,["{",...w(1),"}"]),[a(...c(0),...b(),`${re} interface ${u} {`,...w(0),"}",t,K(`Creates a ${u} object`),`${re} function create${u}(): ${u};`),a(...c(1),`${re} const create${u}: typeof create${u}Decl = () => {`,...C(),`return Object.freeze(${g});`,"};")]},De={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Fe=(e=>{const l=new WeakMap;return t=>(l.has(t)||l.set(t,e(t)),l.get(t))})((e=>{const l=()=>{const l=g(e.getSchemaJson());return!te(l)||s(e.getTableIds(),(t=>{const a=e.getRowIds(t),o=k();if(s(a,(l=>s(e.getCellIds(t,l),(a=>{const n=e.getCell(t,l,a),d=J(o,a,(()=>[ae(n),k(),[0],0])),[r,s,[$]]=d,i=J(s,n,(()=>0))+1;return i>$&&(d[2]=[i,n]),A(s,n,i),d[3]++,r==ae(n)})))))return l[t]={},v(o,(([e,,[,o],n],s)=>{l[t][s]={[d]:e,...n==c(a)?{[r]:o}:{}}})),1}))?l:{}},t=e=>ze(l(),e),a=async e=>{let l;try{l=(await import("prettier")).format}catch{l=e=>e}return I(t(e),(e=>B(l(e,De))))};return ee({getStoreStats:l=>{let t=0,a=0,o=0;const n={};return e.forEachTable(((e,d)=>{t++;let r=0,s=0;const $={};d(((e,t)=>{r++;let a=0;t((()=>a++)),s+=a,l&&($[e]={rowCells:a})})),a+=r,o+=s,l&&(n[e]={tableRows:r,tableCells:s,rows:$})})),{totalTables:t,totalRows:a,totalCells:o,jsonLength:Q(e.getJson()),...l?{detail:{tables:n}}:{}}},getStoreSchema:l,getStoreApi:t,getPrettyStoreApi:a})}));e.createTools=Fe},"object"==typeof exports&&"undefined"!=typeof module?l(exports):"function"==typeof define&&define.amd?define(["exports"],l):l((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBaseTools={});
