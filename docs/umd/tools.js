var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,l="",a=t(l),o=t(!0),n=t(0),r="type",s="default",d=(e,t)=>e.every(t),i=(e,t)=>e.sort(t),$=(e,t)=>e.forEach(t),c=(e,t)=>e.map(t),I=e=>e.length,b=(e,...t)=>e.push(...t),h=e=>e.shift(),w=JSON.parse,u=isFinite,f=e=>null==e,C=e=>Array.isArray(e),g=(e,t)=>e?.has(t)??!1,T=e=>[...e?.values()??[]],R=(e,t)=>e?.forEach(t),p=e=>new Map(e),v=(e,t)=>e?.get(t),m=(e,t)=>c([...e?.entries()??[]],(([e,l])=>t(l,e))),S=(e,t,l)=>{return f(l)?(a=t,e?.delete(a),e):e?.set(t,l);var a},y=(e,t,l)=>(g(e,t)||S(e,t,l()),v(e,t)),L=e=>new Set(C(e)||f(e)?e:[e]),k=/[^A-Za-z0-9]+/,A=/^( *)\/\*\* *(.*?) *\*\/$/gm,E=(e,t,l)=>e.substring(t,l),x=e=>e.toUpperCase(),j=e=>e.toLowerCase(),J=(e,t,l,a=1)=>{const o=`${t}${1==a?"":a}`;return g(e,o)?J(e,t,l,a+1):(S(e,o,l),o)},O=e=>e.length,N=(e,t="")=>e.join(t),G=(e,t=0)=>N(c(e.split(k),((e,l)=>(l>0||t?x:j)(E(e,0,1))+E(e,1)))),z=e=>x(N(e.split(k),"_")),D=e=>`/** ${e}. */`,F=()=>{const e=[p(),p()],t=p(),a=p(),o=p();return[(...e)=>{const t=[],l=e=>C(e)?$(e,l):b(t,e);return $(e,l),t.join("\n")},(t,l,...a)=>$(a,(a=>{return o=y(e[t],l,L),n=a,o?.add(n);var o,n})),(e,l="",a="")=>J(t,e,[l,a]),(e,l,a)=>S(t,e,[l,a]),(e,t,l,o,n,r="")=>J(a,e,[t,l,o,n,r]),(e,t,l)=>J(o,e,C(l)?[`(${t}) => {`,l,"}"]:[`(${t}) => ${l}`]),(e,t)=>v(o,e)===t?e:J(o,e,t),t=>[...i(m(e[t],((e,t)=>`import {${N(i(T(e)),", ")}} from '${t}';`))),l],()=>m(t,(([e,t],a)=>[D(t),`export type ${a} = ${e};`,l])),e=>m(a,(([t,a,o,n,r],s)=>{const d=e?[`${s}: ${r}(${t}): ${a} => ${o},`]:[`${s}${r}(${t}): ${a};`];return e||((e,...t)=>{e.unshift(...t)})(d,D(n)),b(d,l),d})),()=>m(o,((e,t)=>(e=C(e)?e:[e],b(e,e.pop()+";"),[`const ${t} = ${h(e)}`,e,l])))]},M=Object,W=M.keys,P=M.freeze,_=(e,t)=>{return a=e=>e[t],f(l=e)?o?.():a(l);var l,a,o},B=(e,t)=>$(M.entries(e),(([e,l])=>t(l,e))),Q=e=>{return t=W(e),0==I(t);var t},U=e=>{const l=t(e);return(e=>e==a||e==o)(l)||l==n&&u(e)?l:void 0},Z="the Store",q="the specified Row",H="Registers a listener that will be called",K=(e,t="",l="")=>`store.${e}(${t})${l?" as "+l:""}`,V=(e,t="")=>`fluent(() => ${K(e,t)})`,X=(e,t,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in ${t}`,Y=(e,t)=>`Calls a function for each ${e} in ${t}`,ee=(e,t=Z)=>`Gets whether ${e} exists in ${t}`,te=e=>"A function that takes "+e,le=(e,t,l=0)=>`${H} whenever ${e} in ${t} change`+(l?"":"s"),ae=(e=0)=>1==e?"Sets":2==e?"Sets part of":3==e?"Deletes":"Gets",oe=(e,l)=>{if(Q(e))return[n="// store has no inferable schema",n];var n;const d=G(l),i=G(l,1),$=G(i),c=`return ${$};`,I=[],h=[],w=[],u=[],C=[],g=[],v=[],m=(e,t="",l="")=>`store.${e}(${t?t+", ":""}proxy(listener)${l?", "+l:""})`,[y,L,k,A,E,x,j,J,O,M,W]=F();L(0,"tinybase","CellChange","ChangedCells","Id","IdOrNull","Ids","InvalidCells","Json","Store"),L(1,"tinybase","ChangedCells","Id","IdOrNull","Ids","InvalidCells","Json","Store","createStore"),x("fluent","actions: () => Store",["actions();",c]),x("proxy","listener: any",`(_: Store, ...args: any[]) => listener(${$}, ...args)`);const P=j(z(r),"'type'"),U=j(z(s),"'default'"),oe=k("Tables"),ne=k("TableId"),re=k("TableCallback"),se=k("GetCellChange"),de=k("TablesListener",`(${$}: ${i}, getCellChange: ${se} | undefined) => void`,"A function for listening to changes to the content of the Store"),ie=k("TableIdsListener",`(${$}: ${i}) => void`,"A function for listening to changes to Table Ids in the Store"),$e=k("TableListener",`(${$}: ${i}, tableId: ${ne}, getCellChange: ${se} | undefined) => void`,"A function for listening to changes to a Table in the Store"),ce=k("RowIdsListener",`(${$}: ${i}, tableId: ${ne}) => void`,"A function for listening to changes to Row Ids in the Store"),Ie=k("RowListener",`(${$}: ${i}, tableId: ${ne}, rowId: Id, getCellChange: ${se} | undefined) => void`,"A function for listening to changes to a Row in the Store"),be=k("CellIdsListener",`(${$}: ${i}, tableId: ${ne}, rowId: Id) => void`,"A function for listening to changes to Cell Ids in the Store"),he=k("CellListener"),we=k("InvalidCellListener",`(${$}: ${i}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;`,"A function for listening to invalid Cell changes"),ue=k("TransactionListener",`(${$}: ${i}, cellsTouched: boolean) => void;`,"A function for listening to the completion of a transaction");L(1,`./${d}.d`,i,`create${i} as create${i}Decl`,oe,ne,re,de,ie,$e,ce,Ie,be,he,we,ue);const fe=(e=0)=>ae(e)+" the content of the Store";E("hasTables","",o,K("hasTables"),ee("any Table")),E("getTables","",oe,K("getTables"),fe()),E("setTables","tables: "+oe,i,V("setTables","tables"),fe(1)),E("delTables","",i,V("delTables"),fe(3)),E("getTableIds","",ne+"[]",K("getTableIds","",ne+"[]"),X("Table",Z)),E("forEachTable","tableCallback: "+re,"void",K("forEachTable","tableCallback as any"),Y("Table",Z));const Ce=p();var ge;return B(e,((e,l)=>{const n=G(l,1),r=j(z(l),`'${l}'`),c=[],T=[],R=[],p=[],m=`the '${l}' Table`,y="the specified Row in "+m,x="the content of "+m,J=(e=0)=>`${ae(e)} the content of ${m}`,O=(e=0)=>`${ae(e)} the content of ${y}`,D=(e=0)=>`Represents a Row when ${e?"s":"g"}etting ${x}`,F=k(n+"Table",`{[rowId: Id]: ${n}Row}`,"Represents "+m),M=k(n+"Row"),W=k(n+"RowWhenSet"),Q=k(n+"CellId"),Z=k(n+"CellCallback"),H=k(n+"RowCallback");L(1,`./${d}.d`,F,M,W,Q,Z,H),E(`has${n}Table`,"",o,K("hasTable",r),ee(m)),E(`get${n}Table`,"",F,K("getTable",r,F),J()),E(`set${n}Table`,"table: "+F,i,V("setTable",r+", table"),J(1)),E(`del${n}Table`,"",i,V("delTable",r),J(3)),E(`get${n}RowIds`,"","Ids",K("getRowIds",r),X("Row",m)),E(`get${n}SortedRowIds`,`cellId?: ${Q}, descending?: boolean, offset?: number, limit?: number`,"Ids",K("getSortedRowIds",r+", cellId, descending, offset, limit"),X("Row",m,1)),E(`forEach${n}Row`,"rowCallback: "+H,"void",K("forEachRow",r+", rowCallback as any"),Y("Row",m)),E(`has${n}Row`,"rowId: Id",o,K("hasRow",r+", rowId"),ee(q,m)),E(`get${n}Row`,"rowId: Id",M,K("getRow",r+", rowId",M),O()),E(`set${n}Row`,"rowId: Id, row: "+W,i,V("setRow",r+", rowId, row"),O(1)),E(`add${n}Row`,"row: "+W,"Id | undefined",K("addRow",r+", row"),"Adds a new Row to "+m),E(`set${n}PartialRow`,"rowId: Id, partialRow: "+W,i,V("setPartialRow",r+", rowId, partialRow"),O(2)),E(`del${n}Row`,"rowId: Id",i,V("delRow",r+", rowId"),O(3)),E(`get${n}CellIds`,"rowId: Id",Q+"[]",K("getCellIds",r+", rowId",Q+"[]"),X("Cell",y)),E(`forEach${n}Cell`,"rowId: Id, cellCallback: "+Z,"void",K("forEachCell",r+", rowId, cellCallback as any"),Y("Cell",y)),b(v,`[${r}]: {`),B(e,((e,d)=>{const I=G(d,1),h=j(z(d),`'${d}'`),w=e.type,u=!f(_(e,s)),g=e.default,m=`the '${d}' Cell`,L=(e=0)=>`${ae(e)} ${m} for ${y}`;var k;b(v,`[${h}]: {[${P}]: ${j(z(w),`'${w}'`)}${u?`, [${U}]: ${k=g,t(k)==a?j(z(g),`'${g}'`):g}`:""}},`),b(c,`'${d}'${u?"":"?"}: ${w};`),b(T,`'${d}'?: ${w};`),b(R,`'${d}'`),b(p,`[cellId: '${d}', cell: ${w}]`),b(C,`[${$}: ${i}, tableId: '${l}', rowId: Id, cellId: '${d}', newCell: ${w} | undefined, oldCell: ${w} | undefined, getCellChange: ${se} | undefined]`);const A="Map"+G(w,1);S(Ce,w,A),E(`has${n}${I}Cell`,"rowId: Id",o,K("hasCell",`${r}, rowId, ${h}`),ee(m,y));const x=`${w}${u?"":" | undefined"}`;E(`get${n}${I}Cell`,"rowId: Id",x,K("getCell",`${r}, rowId, ${h}`,x),L()),E(`set${n}${I}Cell`,`rowId: Id, cell: ${w} | ${A}`,i,V("setCell",`${r}, rowId, ${h}, cell as any`),L(1)),E(`del${n}${I}Cell`,"rowId: Id",i,V("delCell",`${r}, rowId, ${h}`),L(3))})),b(v,"},"),b(I,`'${l}'?: ${F};`),b(h,`'${l}'`),b(w,`[tableId: '${l}', forEachRow: (rowCallback: ${H}) => void]`),b(u,`[tableId: '${l}', rowId: Id, cellId: ${Q}]`),b(g,Q),A(M,`{${N(c," ")}}`,D()),A(W,`{${N(T," ")}}`,D(1)),A(Q,N(R," | "),"A Cell Id for "+m),A(Z,`(...[cellId, cell]: ${N(p," | ")}) => void`,te("a Cell Id and value from a Row in "+m)),A(H,`(rowId: Id, forEachCell: (cellCallback: ${Z}) => void) => void`,te(`a Row Id from ${m}, and a Cell iterator`))})),E("getJson","","Json",K("getJson"),"Gets a a string serialization the content of the Store"),E("setJson","json: Json",i,V("setJson","json"),"Sets the content of the Store from a serialized string"),E("transaction","actions: () => Return, doRollback?: (changedCells: ChangedCells, invalidCells: InvalidCells) => boolean","Return",K("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),E("startTransaction","",i,V("startTransaction"),"Explicitly starts a transaction"),E("finishTransaction","doRollback?: (changedCells: ChangedCells, invalidCells: InvalidCells) => boolean,",i,V("finishTransaction","doRollback"),"Explicitly finishes a transaction"),E("addTablesListener",`listener: ${de}, mutator?: boolean`,"Id",m("addTablesListener","","mutator"),H+" whenever the content of the Store changes"),E("addTableIdsListener",`listener: ${ie}, mutator?: boolean`,"Id",m("addTableIdsListener","","mutator"),le("the Table Ids",Z,1)),E("addTableListener",`tableId: ${ne} | null, listener: ${$e}, mutator?: boolean`,"Id",m("addTableListener","tableId","mutator"),le("a Table",Z)),E("addRowIdsListener",`tableId: ${ne} | null, listener: ${ce}, mutator?: boolean`,"Id",m("addRowIdsListener","tableId","mutator"),le("the Row Ids","a Table",1)),E("addRowListener",`tableId: ${ne} | null, rowId: IdOrNull, listener: ${Ie}, mutator?: boolean`,"Id",m("addRowListener","tableId, rowId","mutator"),le("a Row","a Table")),E("addCellIdsListener",`tableId: ${ne} | null, rowId: IdOrNull, listener: ${be}, mutator?: boolean`,"Id",m("addCellIdsListener","tableId, rowId","mutator"),le("the Cell Ids","a Row",1)),E("addCellListener",`tableId: ${ne} | null, rowId: IdOrNull, cellId: ${N(g," | ")} | null, listener: ${he}, mutator?: boolean`,"Id",m("addCellListener","tableId, rowId, cellId","mutator"),le("a Cell","a Row")),E("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: ${we}, mutator?: boolean`,"Id",m("addCellListener","tableId, rowId, cellId","mutator"),H+" whenever an invalid Cell change was attempted"),E("addWillFinishTransactionListener","listener: "+ue,"Id",m("addWillFinishTransactionListener"),H+" just before the end of the transaction"),E("addDidFinishTransactionListener","listener: "+ue,"Id",m("addDidFinishTransactionListener"),H+" just after the end of the transaction"),E("callListener","listenerId: Id",i,V("callListener","listenerId"),"Manually provoke a listener to be called"),E("delListener","listenerId: Id",i,V("delListener","listenerId"),"Remove a listener that was previously added to the Store"),E("getStore","","Store","store","Gets the underlying Store object"),A(oe,`{${N(I," ")}}`,"Represents the content of the Store"),A(ne,N(h," | "),"A Table Id in the Store"),A(re,`(...[tableId, rowCallback]: ${N(w," | ")}) => void`,te("a Table Id, and a Row iterator")),A(se,`(...[tableId, rowId, cellId]: ${N(u," | ")}) => CellChange`,"A function that returns information about any Cell's changes during a transaction"),A(he,`(...[${$}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${N(C," | ")}) => void`,"A function for listening to changes to a Cell in the Store"),ge=(e,t)=>k(t,`(cell: ${e} | undefined) => ${e}`,`Takes a ${e} Cell value and returns another`),R(Ce,((e,t)=>ge(t,e))),L(1,`./${d}.d`,...T(Ce)),j("store",["createStore().setSchema({",...v,"})"]),j($,["{",...M(1),"}"]),[y(...J(0),...O(),`export interface ${i} {`,...M(0),"}","",D(`Creates a ${i} object`),`export function create${i}(): ${i};`),y(...J(1),`export const create${i}: typeof create${i}Decl = () => {`,...W(),`return Object.freeze(${$});`,"};")]},ne={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},re=(e=>{const t=new WeakMap;return l=>(t.has(l)||t.set(l,e(l)),t.get(l))})((e=>{const t=()=>{const t=w(e.getSchemaJson());return!Q(t)||d(e.getTableIds(),(l=>{const a=e.getRowIds(l),o=p();if(d(a,(t=>d(e.getCellIds(l,t),(a=>{const n=e.getCell(l,t,a),r=y(o,a,(()=>[U(n),p(),[0],0])),[s,d,[i]]=r,$=y(d,n,(()=>0))+1;return $>i&&(r[2]=[$,n]),S(d,n,$),r[3]++,s==U(n)})))))return t[l]={},R(o,(([e,,[,o],n],d)=>{t[l][d]={[r]:e,...n==I(a)?{[s]:o}:{}}})),1}))?t:{}},l=e=>oe(t(),e);return P({getStoreStats:t=>{let l=0,a=0,o=0;const n={};return e.forEachTable(((e,r)=>{l++;let s=0,d=0;const i={};r(((e,l)=>{s++;let a=0;l((()=>a++)),d+=a,t&&(i[e]={rowCells:a})})),a+=s,o+=d,t&&(n[e]={tableRows:s,tableCells:d,rows:i})})),{totalTables:l,totalRows:a,totalCells:o,jsonLength:O(e.getJson()),...t?{detail:{tables:n}}:{}}},getStoreSchema:t,getStoreApi:l,getPrettyStoreApi:async e=>{const t=l(e);try{const{format:e}=await import("prettier");return c(t,(t=>(e=>e.replace(A,((e,t,l)=>{const a=77-O(t);return`${t}/**\n${l.replace(RegExp(`([^\\n]{1,${a}})(\\s|$)`,"g"),t+" * $1\n")}${t} */`})))(e(t,ne))))}catch{}return t}})}));e.createTools=re},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBaseTools={});
