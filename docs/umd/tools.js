var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,l="",a=t(l),n=t(!0),o=t(0),r="type",s="default",d="Listener",c="get",$="add",i="Ids",u="Table",I=u+"s",b=u+i,h="Row",f=h+i,p="Sorted"+h+i,g="Cell",w=g+i,C="Value",m=C+"s",y=C+i,v=(e,t)=>e.every(t),R=(e,t)=>e.sort(t),S=(e,t)=>e.forEach(t),k=(e,t)=>e.map(t),V=e=>e.length,x=e=>0==V(e),T=(e,t)=>e.filter(t),O=(e,...t)=>e.push(...t),D=e=>e.pop(),A=(e,...t)=>e.unshift(...t),N=e=>e.shift(),P=JSON.parse,j=isFinite,E=(e,t)=>e instanceof t,M=e=>null==e,z=e=>e==a||e==n,G=e=>t(e)==a,J=e=>Array.isArray(e),B=e=>{const l=t(e);return z(l)||l==o&&j(e)?l:void 0},L=(e,t)=>e?.has(t)??!1,W=e=>[...e?.values()??[]],F=(e,t)=>e?.forEach(t),U=(e,t)=>e?.delete(t),_=e=>new Map(e),Z=(e,t)=>e?.get(t),H=(e,t)=>F(e,((e,l)=>t(l,e))),Q=(e,t)=>k([...e?.entries()??[]],(([e,l])=>t(l,e))),q=(e,t,l)=>M(l)?(U(e,t),e):e?.set(t,l),K=(e,t,l)=>(L(e,t)||q(e,t,l()),Z(e,t)),X=e=>e.toUpperCase(),Y=e=>e.toLowerCase(),ee="a ",te="A function for",le="Callback",ae="Del",ne="export",oe="Id",re="Invalid",se="Json",de=Y(d),ce=" | undefined",$e="Partial",ie=`Registers a ${de} that will be called`,ue="Represents",Ie="Set",be="[]",he="the Store",fe="Transaction",pe=Y(fe),ge="the end of the "+pe,we="void",Ce=" => "+we,me=ee+"string serialization of",ye=" ",ve="Gets a callback that can ",Re="the ",Se=(e=0,t=0)=>`the ${Be[e]}content of`+(t?ye+he:l),ke=(e=0,t,a=0)=>Ge[t]+ye+Se(e,1)+(a?" when set":l),Ve=(e,t=0)=>ue+` a Row when ${t?"s":"g"}etting ${Se()} the '${e}' `+u,xe=(e,t,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in `+t,Te=(e,t)=>`Calls a function for each ${e} in `+t,Oe=e=>"A function that takes "+e,De=(e,t=0)=>te+" listening to changes to "+Je[e]+" in "+Je[t],Ae=(e,t,a=0)=>ie+" whenever "+Je[e]+" in "+Je[t]+" change"+(a?l:"s"),Ne=e=>`the '${e}' `+u,Pe=e=>"the specified Row in "+Ne(e),je=(e,t=0)=>Ge[t]+` ${Se()} `+Ne(e),Ee=(e,t=0)=>Ge[t]+` ${Se()} `+Pe(e),Me=(e,t,l=0)=>Ge[l]+` the '${t}' Cell for `+Pe(e),ze=(e,t=0)=>Ge[t]+` the '${e}' Value`,Ge=["Gets","Checks existence of","Sets","Deletes","Sets part of",ue,"Gets "+me,"Sets "+me,ie+" whenever",ve+"set",ve+"add",ve+"set part of",ve+"delete"],Je=[he,I,Re+u+ye+i,ee+u,Re+h+ye+i,ee+h,Re+g+ye+i,ee+g,"invalid Cell changes",m,Re+C+ye+i,ee+C,"invalid Value changes",Re+"sorted "+h+ye+i],Be=[l,"tabular ","keyed value "],Le=e=>new Set(J(e)||M(e)?e:[e]),We=(e,t)=>e?.add(t),Fe=/[^A-Za-z]+/,Ue=/[^A-Za-z0-9]+/,_e=/^( *)\/\*\* *(.*?) *\*\/$/gm,Ze=(e,t,l)=>e.substring(t,l),He=e=>e.includes(","),Qe=(e,t,l,a=1)=>{const n=`${t}${1==a?"":a}`;return L(e,n)?Qe(e,t,l,a+1):(q(e,n,l),n)},qe=e=>e.replace(_e,((e,t,l)=>{const a=77-Ke(t);return`${t}/**\n${l.replace(RegExp(`([^\\n]{1,${a}})(\\s|$)`,"g"),t+" * $1\n")}${t} */`})),Ke=e=>e.length,Xe=(e,t=l)=>e.join(t),Ye=e=>e.flat(1e3),et=(e,t=0)=>Xe(k(e.split(Ue),((e,l)=>(l>0||t?X:Y)(Ze(e,0,1))+Ze(e,1)))),tt=e=>X(Xe((e&&!Fe.test(e[0])?e:" "+e).split(Ue),"_")),lt=e=>`/** ${e}. */`,at=(...e)=>Xe(T(e,(e=>e)),", "),nt=()=>{const e=[_(),_(),_(),_()],t=_(),a=_();return[(...e)=>Xe(Ye(e),"\n"),(t,l,...a)=>S(a,(a=>S([0,1],(n=>(t??n)==n?We(K(e[n],l,Le),a):0)))),(e,l,a)=>Qe(t,e,[l,a]),(e,t,l)=>Qe(a,e,J(l)?[`(${t}) => {`,l,"}"]:[`(${t}) => ${l}`]),(e,t)=>Z(a,e)===t?e:Qe(a,e,t),(t=0)=>k([...R(Q(e[t],((e,t)=>`import {${Xe(R(W(e)),", ")}} from '${t}';`)),((e,t)=>He(e)!=He(t)?He(e)?-1:1:e>t?1:-1)),l],(e=>e.replace("{React}","React"))),()=>Q(t,(([e,t],a)=>[lt(t),`${ne} type ${a} = ${e};`,l])),()=>Q(a,((e,t)=>(e=J(e)?e:[e],O(e,D(e)+";"),[`const ${t} = ${N(e)}`,e,l])))]},ot=Object,rt=ot.keys,st=ot.freeze,dt=e=>E(e,ot)&&e.constructor==ot,ct=(e,t)=>k(ot.entries(e),(([e,l])=>t(l,e))),$t=e=>dt(e)&&x(rt(e)),it=e=>{const t=new WeakMap;return l=>(t.has(l)||t.set(l,e(l)),t.get(l))},ut=(e,t,l)=>[t=>ct(e,((e,a)=>t(a,et(a,1),l(tt(a),`'${a}'`)))),(t,a)=>ct(e[t],((e,t)=>a(t,e[r],e[s],l(tt(t),`'${t}'`),et(t,1)))),e=>ct(t,((t,a)=>e(a,t[r],t[s],l(tt(a),`'${a}'`),et(a,1))))],It=[c,"has","set","del","set","forEach",$,l],bt=(e,t=l,a=l)=>`store.${e}(${t})`+(a?" as "+a:l),ht=(e,t=l)=>`fluent(() => ${bt(e,t)})`,ft=(e,t=l,a=l)=>`store.${e}(${t?t+", ":l}proxy(listener)${a?", "+a:l})`,pt=(e,t,a)=>{const[o,c,v,R,k,V,x,T]=nt(),[D,N,P]=ut(e,t,k),j=_(),E=(e=0)=>Q(j,(([t,a,n,o,r],s)=>{const d=e?[s+`: ${r}(${t}): ${a} => ${n},`]:[s+r+`(${t}): ${a};`];return e||A(d,lt(o)),O(d,l),d})),z=(e,t,a,n,o,r=l)=>Qe(j,e,[t,a,n,o,r]),J=(e,t,a,n,o,r=l,s=l,d=l)=>z(It[e]+t+(4==e?$e:l)+a,r,n,(n==F?ht:bt)(It[e]+(4==e?$e:l)+a,s,e?void 0:n),o,d),B=(e,t,a,n=l,o=l,r=1)=>z($+e+d,(n?n+", ":l)+de+": "+t+(r?", mutator?: boolean":l),oe,ft($+e+d,o,r?"mutator":l),a),L=`./${et(a)}.d`,F=et(a,1),U=et(F),K=[],X=_();let Y=[],ae=[];if(c(1,L,F,`create${F} as create${F}Decl`),!$t(e)){const e=_();D(((t,a)=>{const n=[v(a+u,`{[rowId: Id]: ${a}Row}`,ue+` the '${t}' `+u),v(a+h,`{${Xe(N(t,((e,t,a)=>`'${e}'${M(a)?"?":l}: ${t};`))," ")}}`,Ve(t)),v(a+h+"WhenSet",`{${Xe(N(t,((e,t)=>`'${e}'?: ${t};`))," ")}}`,Ve(t,1)),v(a+g+oe,Xe(N(t,(e=>`'${e}'`))," | "),`A Cell Id for the '${t}' `+u),v(a+g+le,`(...[cellId, cell]: ${Xe(N(t,((e,t)=>`[cellId: '${e}', cell: ${t}]`))," | ")})`+Ce,Oe(`a Cell Id and value from a Row in the '${t}' `+u)),v(a+h+le,`(rowId: Id, forEachCell: (cellCallback: ${a}CellCallback)`+Ce+")"+Ce,Oe(`a Row Id from the '${t}' Table, and a Cell iterator`))];q(e,t,n),c(1,L,...n)}));const t=v(I,`{${Xe(D((t=>`'${t}'?: ${Z(e,t)?.[0]};`))," ")}}`,ke(1,5)),a=v(u+oe,Xe(D((e=>`'${e}'`))," | "),"A "+u+" Id in "+he),o=v(u+le,`(...[tableId, rowCallback]: ${Xe(D((t=>`[tableId: '${t}', forEachRow: (rowCallback: ${Z(e,t)?.[5]})${Ce}]`))," | ")})`+Ce,Oe(ee+u+" Id, and a Row iterator")),$=v("GetCellChange",`(...[tableId, rowId, cellId]: ${Xe(D((t=>`[tableId: '${t}', rowId: Id, cellId: ${Z(e,t)?.[3]}]`))," | ")}) => CellChange`,te+" returning information about any Cell's changes during a "+pe),C=v(I+d,`(${U}: ${F}, getCellChange: ${$}${ce})`+Ce,De(1)),m=v(b+d,`(${U}: ${F})`+Ce,De(2)),y=v(u+d,`(${U}: ${F}, tableId: ${a}, getCellChange: ${$}${ce})`+Ce,De(3)),R=v(f+d,`(${U}: ${F}, tableId: ${a})`+Ce,De(4,3)),V=v(p+d,"("+at(U+": "+F,"tableId: "+a,"cellId: Id"+ce,"descending: boolean","offset: number","limit: number"+ce,"sortedRowIds: Ids")+")"+Ce,De(13,3)),x=v(h+d,`(${U}: ${F}, tableId: ${a}, rowId: Id, getCellChange: ${$}${ce})`+Ce,De(5,3)),T=v(w+d,`(${U}: ${F}, tableId: ${a}, rowId: Id)`+Ce,De(6,5)),A=v(g+d,`(...[${U}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${Xe(Ye(D((e=>N(e,((t,l)=>`[${U}: ${F}, tableId: '${e}', rowId: Id, cellId: '${t}', newCell: ${l}${ce}, oldCell: ${l}${ce}, getCellChange: ${$} | undefined]`)))))," | ")})`+Ce,De(7,5)),P=v(re+g+d,`(${U}: ${F}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])`+Ce,De(8));Y=[t,a,C,m,y,R,V,x,T,A,e],S([[t],[n],[F,"tables: "+t,"tables"],[F]],(([e,t,a],n)=>J(n,l,I,e,ke(1,n),t,a))),J(0,l,b,a+be,xe(u,he)),J(5,l,u,we,Te(u,he),"tableCallback: "+o,"tableCallback as any"),D(((t,a,o)=>{const[r,s,d,c,$,I]=Z(e,t);S([[r],[n],[F,"table: "+r,", table"],[F]],(([e,n,r=l],s)=>J(s,a,u,e,je(t,s),n,o+r))),J(0,a,f,i,xe(h,Ne(t)),l,o),J(0,a,p,i,xe(h,Ne(t),1),"cellId?: "+c+", descending?: boolean, offset?: number, limit?: number",o+", cellId, descending, offset, limit"),J(5,a,h,we,Te(h,Ne(t)),"rowCallback: "+I,o+", rowCallback as any"),S([[s],[n],[F,", row: "+d,", row"],[F],[F,", partialRow: "+d,", partialRow"]],(([e,n=l,r=l],s)=>J(s,a,h,e,Ee(t,s),"rowId: Id"+n,o+", rowId"+r))),J(6,a,h,oe+ce,"Adds a new Row to "+Ne(t),"row: "+d,o+", row"),J(0,a,w,c+be,xe(g,Pe(t)),"rowId: "+oe,o+", rowId"),J(5,a,g,we,Te(g,Pe(t)),"rowId: Id, cellCallback: "+$,o+", rowId, cellCallback as any"),N(t,((e,r,s,d,c)=>{const $="Map"+et(r,1);q(X,r,$);const i=r+(M(s)?ce:l);S([[i],[n],[F,`, cell: ${r} | `+$,", cell as any"],[F]],(([n,r=l,s=l],$)=>J($,a+c,g,n,Me(t,e,$),"rowId: Id"+r,o+", rowId, "+d+s)))}))})),J(0,l,I+se,se,ke(1,6)),J(2,l,I+se,F,ke(1,7),"tablesJson: "+se,"tables"+se),B(I,C,ke(1,8)+" changes"),B(b,m,Ae(2,0,1)),B(u,y,Ae(3,0),`tableId: ${a} | null`,"tableId"),B(f,R,Ae(4,3,1),`tableId: ${a} | null`,"tableId"),B(p,V,Ae(13,3,1),at("tableId: "+a,"cellId: Id"+ce,"descending: boolean","offset: number","limit: number"+ce),at("tableId","cellId","descending","offset","limit")),B(h,x,Ae(5,3),`tableId: ${a} | null, rowId: IdOrNull`,"tableId, rowId"),B(w,T,Ae(6,5,1),`tableId: ${a} | null, rowId: IdOrNull`,"tableId, rowId"),B(g,A,Ae(7,5),`tableId: ${a} | null, rowId: IdOrNull, cellId: ${Xe(D((t=>Z(e,t)?.[3]??l))," | ")} | null`,"tableId, rowId, cellId"),B(re+g,P,ie+" whenever an invalid Cell change was attempted","tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull","tableId, rowId, cellId"),c(1,L,t,a,o,C,m,y,R,V,x,T,A,P,...W(X)),c(0,"tinybase","CellChange"),O(K,".setTablesSchema({",Ye(D(((e,t,a)=>[`[${a}]: {`,...N(e,((e,t,a,n)=>`[${n}]: {[${k(tt(r),`'${r}'`)}]: ${k(tt(t),`'${t}'`)}${M(a)?l:`, [${k(tt(s),`'${s}'`)}]: `+(G(a)?k(tt(a),`'${a}'`):a)}},`)),"},"]))),"})")}if(!$t(t)){const e=v(m,"{"+Xe(P(((e,t,a)=>`'${e}'${M(a)?"?":l}: ${t};`))," ")+"}",ke(2,5)),t=v(m+"WhenSet","{"+Xe(P(((e,t)=>`'${e}'?: ${t};`))," ")+"}",ke(2,5,1)),a=v(C+oe,Xe(P((e=>`'${e}'`))," | "),"A Value Id in "+he),o=v(C+le,`(...[valueId, rowCallback]: ${Xe(P(((e,t)=>`[valueId: '${e}', value: ${t}]`))," | ")})`+Ce,Oe("a Value Id, and value")),$=v("GetValueChange",`(valueId: ${a}) => ValueChange`,te+" returning information about any Value's changes during a "+pe),i=v(m+d,`(${U}: ${F}, getValueChange: ${$}${ce})`+Ce,De(9)),u=v(y+d,`(${U}: ${F})`+Ce,De(10)),I=v(C+d,`(...[${U}, valueId, newValue, oldValue, getValueChange]: ${Xe(P(((e,t)=>`[${U}: ${F}, valueId: '${e}', newValue: ${t}${ce}, oldValue: ${t}${ce}, getValueChange: ${$} | undefined]`))," | ")})`+Ce,De(11)),b=v(re+C+d,`(${U}: ${F}, valueId: Id, invalidValues: any[])`+Ce,De(12));ae=[e,t,a,i,u,I],S([[e],[n],[F,"values: "+t,"values"],[F],[F,"partialValues: "+t,"partialValues"]],(([e,t,a],n)=>J(n,l,m,e,ke(2,n),t,a))),J(0,l,y,a+be,xe(C,he)),J(5,l,C,"void",Te(C,he),"valueCallback: "+o,"valueCallback as any"),P(((e,t,a,o,r)=>{const s="Map"+et(t,1);q(X,t,s),S([[t],[n],[F,`value: ${t} | `+s,", value as any"],[F]],(([t,a,n=l],s)=>J(s,r,C,t,ze(e,s),a,o+n)))})),J(0,l,m+se,se,ke(2,6)),J(2,l,m+se,F,ke(2,7),"valuesJson: "+se,"values"+se),B(m,i,ke(2,8)+" changes"),B(y,u,Ae(10,0,1)),B(C,I,Ae(11,0),`valueId: ${a} | null`,"valueId"),B(re+C,b,ie+" whenever an invalid Value change was attempted","valueId: IdOrNull","valueId"),c(1,L,e,t,a,o,i,u,I,b),c(0,"tinybase","ValueChange"),O(K,".setValuesSchema({",P(((e,t,a,n)=>[`[${n}]: {[${k(tt(r),`'${r}'`)}]: ${k(tt(t),`'${t}'`)}${M(a)?l:`, [${k(tt(s),`'${s}'`)}]: `+(G(a)?k(tt(a),`'${a}'`):a)}},`])),"})")}H(X,((e,t)=>v(t,`(cell: ${e}${ce}) => `+e,`Takes a ${e} Cell value and returns another`))),c(null,"tinybase","DoRollback",oe,"IdOrNull",i,se,"Store");const Ie=v(fe+d,`(${U}: ${F}, cellsTouched: boolean, valuesTouched: boolean)`+Ce,te+" listening to the completion of a "+pe);return J(0,l,se,se,ke(0,6)),J(2,l,se,F,ke(0,7),"json: "+se,"json"),J(7,l,pe,"Return","Execute a "+pe+" to make multiple mutations","actions: () => Return, doRollback?: DoRollback","actions, doRollback","<Return>"),J(7,l,"start"+fe,F,"Explicitly starts a "+pe),J(7,l,"finish"+fe,F,"Explicitly finishes a "+pe,"doRollback?: DoRollback,","doRollback"),B("WillFinish"+fe,Ie,ie+" just before "+ge,l,l,0),B("DidFinish"+fe,Ie,ie+" just after "+ge,l,l,0),J(7,l,"call"+d,F,"Manually provoke a listener to be called","listenerId: Id","listenerId"),J(3,l,d,F,"Remove a listener that was previously added to "+he,"listenerId: Id","listenerId"),z("getStore",l,"Store","store",Ge[0]+" the underlying Store object"),c(1,"tinybase","createStore"),c(1,L,F,`create${F} as create${F}Decl`,Ie),k("store",["createStore()",...K]),R("fluent","actions: () => Store",["actions();",`return ${U};`]),R("proxy","listener: any",`(_: Store, ...params: any[]) => listener(${U}, ...params)`),k(U,["{",...E(1),"}"]),[o(...V(0),...x(),ne+" interface "+F+" {",...E(0),"}",l,lt(`Creates a ${F} object`),ne+" function create"+F+"(): "+F+";"),o(...V(1),ne+" const create"+F+": typeof create"+F+"Decl = () => {",...T(),`return Object.freeze(${U});`,"};"),Y,ae]},gt="Deps",wt=e=>c+e,Ct=e=>at(wt(e),wt(e)+gt),mt="Parameter",yt=": (parameter: "+mt+", store: Store) => ",vt="const contextValue = useContext(Context);",Rt=", and registers a listener so that any changes to that result will cause a re-render",St=", based on a parameter",kt=": ",Vt=mt+"ized"+le+"<"+mt+">",xt="<"+mt+",>",Tt=gt+"?: React.DependencyList",Ot="then"+Tt,Dt="then?: (store: Store",At=at(Dt+")"+Ce,Ot),Nt="then, then"+gt,Pt="rowId",jt=Pt+kt+oe,Et=(e,...t)=>at(...t,de+": "+e,de+Tt,"mutator?: boolean"),Mt=(...e)=>at(...e,de,de+gt,"mutator"),zt=(e,t,a,n,o)=>{const[r,s,c,$,v,R,S,k]=nt(),[V,x,T]=ut(e,t,v),D=`./${et(a)}.d`,N=`./${et(a)}-ui-react.d`,P="tinybase/ui-react",j=et(a,1),E=et(j),z=j+"Or"+j+oe,G=E+"Or"+j+oe,B=_(),L=(e,t,a,n,o,r=l)=>(s(1,N,e+" as "+e+"Decl"),Qe(B,e,[t,a,J(n)?["{",n,"}"]:n,o,r])),W=(e,t,a,n,o,r=l)=>L("use"+e,t,a,n,o,r),F=(e,t,a,n,o=l,r=l,d=l,c=l,$=l)=>{s(1,P,`use${t} as use${t}Core`),W(e,at(o,X,c),a,ee+`(${G}, use${t}Core, [`+(r||l)+($?"], ["+$:l)+"])",n,d)},U=(e,t,l,a)=>L(e,t,1,l,a),H=(e=0)=>Q(B,(([t,a,n,o,r],s)=>{const d=e?[ne+` const ${s}: typeof ${s}Decl = ${r}(${t}): ${1==a?"any":a} =>`,n]:[ne+` function ${s}${r}(${t}): ${1==a?"ComponentReturnType":a};`];return e||A(d,lt(o)),O(d,l),d}));s(null,"tinybase",oe,i,"IdOrNull","Store",le,mt+"ized"+le),s(0,P,"ComponentReturnType"),s(0,D,j);const q=c(z,j+" | "+oe,`Used when you need to refer to a ${j} in a React hook or component`),K=c("ProviderProps",`{readonly ${E}?: ${j}; readonly ${E}ById?: {[${E}Id: Id]: ${j}}}`,`Used with the Provider component, so that a ${j} can be passed into the context of an application`);s(1,"react","React"),s(1,N,q,K);const X=G+"?: "+q;v("{createContext, useContext, useMemo}","React"),v("Context",`createContext<[${j}?, {[${E}Id: Id]: ${j}}?]>([])`),W("Create"+j,`create: () => ${j}, create`+Tt,j,"\n// eslint-disable-next-line react-hooks/exhaustive-deps\nuseMemo(create, createDeps)",`Create a ${j} within a React application with convenient memoization`);const Y=W(j,"id?: Id",j+ce,[vt,"return id == null ? contextValue[0] : contextValue[1]?.[id];"],`Get a reference to a ${j} from within a Provider component context`),ee=$("useHook",G+`: ${q} | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []`,[`const ${E} = ${Y}(${G} as Id);`,`return hook(...preParams, ((${G} == null || typeof ${G} == 'string')`,`? ${E} : ${G})?.getStore(), ...postParams)`]);if(!$t(e)){const[e,t,a,o,r,c,$,C,m,y,v]=n;s(null,D,e,t,a,o,r,c,$,C,m,y),s(1,P),s(1,D,j),F(I,I,e,ke(1,0)+Rt),F(b,b,t+be,xe(u,he)+Rt),F(Ie+I+le,Ie+I+le,Vt,ke(1,9)+St,at(wt(I)+yt+e,wt(I)+Tt),Ct(I),xt,at(Dt,`tables: ${e})`+Ce,Ot),Nt),F(ae+I+le,ae+I+le,le,ke(1,12),l,l,l,At,Nt),V(((e,t,a)=>{const[n,o,r,d]=Z(v,e);s(0,D,n,o,r,d),s(1,D,n,o,r,d),F(t+u,u,n,je(e)+Rt,l,a),F(t+f,f,i,xe(h,Ne(e))+Rt,l,a),F(t+p,p,i,xe(h,Ne(e),1)+Rt,"cellId?: "+d+", descending?: boolean, offset?: number, limit?: number",a+", cellId, descending, offset, limit"),F(t+h,h,o,Ee(e)+Rt,jt,at(a,Pt)),F(t+w,w,d+be,xe(g,Pe(e))+Rt,jt,at(a,Pt)),F(Ie+t+u+le,Ie+u+le,Vt,je(e,9)+St,at(wt(u)+yt+n,wt(u)+Tt),at(a,Ct(u)),xt,at(Dt,`table: ${n})`+Ce,Ot),Nt),F(ae+t+u+le,ae+u+le,le,je(e,12),l,a,l,At,Nt),F(Ie+t+h+le,Ie+h+le,Vt,Ee(e,9)+St,at(jt,wt(h)+yt+r,wt(h)+Tt),at(a,Pt,Ct(h)),xt,at(Dt,`row: ${r})`+Ce,Ot),Nt),F("Add"+t+h+le,"Add"+h+le,Vt,Ee(e,10)+St,at(wt(h)+yt+r,wt(h)+Tt),at(a,Ct(h)),xt,"then?: ("+at(jt+ce,"store: Store","row: "+r+")"+Ce,"then"+Tt),Nt),F(Ie+t+$e+h+le,Ie+$e+h+le,Vt,Ee(e,11)+St,at(jt,wt($e+h)+yt+r,wt($e+h)+Tt),at(a,Pt,Ct($e+h)),xt,at(Dt,`partialRow: ${r})`+Ce,Ot),Nt),F(ae+t+h+le,ae+h+le,le,Ee(e,12),jt,at(a,Pt),l,At,Nt),x(e,((n,o,r,d,c)=>{const $="Map"+et(o,1);s(0,D,$),s(1,D,$),F(t+c+g,g,o+(M(r)?ce:l),Me(e,n)+Rt,jt,at(a,Pt,d)),F(Ie+t+c+g+le,Ie+g+le,Vt,Me(e,n,9)+St,at(jt,wt(g)+yt+o+" | "+$,wt(g)+Tt),at(a,Pt,d,Ct(g)),xt,at(Dt,`cell: ${o} | ${$})`+Ce,Ot),Nt),F(ae+t+c+g+le,ae+g+le,le,Me(e,n,12),at(jt,"forceDel?: boolean"),at(a,Pt,d,"forceDel"),l,At,Nt)}))}));const R=Xe(V((e=>Z(v,e)?.[3]??l))," | ");F(I+d,I+d,we,ke(1,8)+" changes",Et(a),Mt()),F(b+d,b+d,we,Ae(2,0,1),Et(o),Mt()),F(u+d,u+d,we,Ae(3,0),Et(r,`tableId: ${t} | null`),Mt("tableId")),F(f+d,f+d,we,Ae(4,3,1),Et(c,`tableId: ${t} | null`),Mt("tableId")),F(p+d,p+d,we,Ae(13,3,1),Et($,`tableId: ${t} | null`,"cellId: "+R+ce,"descending: boolean","offset: number","limit: number"+ce),Mt("tableId","cellId","descending","offset","limit")),F(h+d,h+d,we,Ae(5,3),Et(C,`tableId: ${t} | null`,Pt+": IdOrNull"),Mt("tableId",Pt)),F(w+d,w+d,we,Ae(6,5,1),Et(m,`tableId: ${t} | null`,Pt+": IdOrNull"),Mt("tableId",Pt)),F(g+d,g+d,we,Ae(7,5),Et(y,`tableId: ${t} | null`,Pt+": IdOrNull",`cellId: ${R} | null`),Mt("tableId",Pt,"cellId"))}if(!$t(t)){const[e,t,a,n,r,c]=o;s(null,D,...o),F(m,m,e,ke(2,0)+Rt),F(y,y,a+be,xe(C,he)+Rt),F(Ie+m+le,Ie+m+le,Vt,ke(2,9)+St,at(wt(m)+yt+t,wt(m)+Tt),Ct(m),xt,at(Dt,`values: ${t})`+Ce,Ot),Nt),F(Ie+$e+m+le,Ie+$e+m+le,Vt,ke(2,11)+St,at(wt($e+m)+yt+t,wt($e+m)+Tt),Ct($e+m),xt,at(Dt,`partialValues: ${t})`+Ce,Ot),Nt),F(ae+m+le,ae+m+le,le,ke(2,12),l,l,l,At,Nt),T(((e,t,a,n,o)=>{const r="Map"+et(t,1);s(0,D,r),s(1,D,r),F(o+C,C,t,ze(e)+Rt,l,n),F(Ie+o+C+le,Ie+C+le,Vt,ze(e,9)+St,at(wt(C)+yt+t+" | "+r,wt(C)+Tt),at(n,Ct(C)),xt,at(Dt,`value: ${t} | ${r})`+Ce,Ot),Nt),F(ae+o+C+le,ae+C+le,le,ze(e,12),l,n,l,At,Nt)})),F(m+d,m+d,we,ke(2,8)+" changes",Et(n),Mt()),F(y+d,y+d,we,Ae(10,0,1),Et(r),Mt()),F(C+d,C+d,we,Ae(11,0),Et(c,`valueId: ${a} | null`),Mt("valueId"))}return U("Provider",`{${E}, ${E}ById, children}: `+K+" & {children: React.ReactNode}",[vt,"return (","<Context.Provider","value={useMemo(",`() => [${E} ?? contextValue[0], {...contextValue[1], ...${E}ById}],`,`[${E}, ${E}ById, contextValue],`,")}>","{children}","</Context.Provider>",");"],"Wraps part of an application in a context that provides default objects to be used by hooks and components within"),[r(...R(0),...S(),...H(0)),r(...R(1),...k(),...H(1))]},Gt=(e,t,a)=>{if($t(e)&&$t(t))return[l,l,l,l];const[n,o,r,s]=pt(e,t,a);return[n,o,...zt(e,t,a,r,s)]},Jt={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Bt=it((e=>{const t=()=>{const t=P(e.getTablesSchemaJson());return!$t(t)||v(e.getTableIds(),(l=>{const a=e.getRowIds(l),n=_();if(v(a,(t=>v(e.getCellIds(l,t),(a=>{const o=e.getCell(l,t,a),r=K(n,a,(()=>[B(o),_(),[0],0])),[s,d,[c]]=r,$=K(d,o,(()=>0))+1;return $>c&&(r[2]=[$,o]),q(d,o,$),r[3]++,s==B(o)})))))return t[l]={},F(n,(([e,,[,n],o],d)=>{t[l][d]={[r]:e,...o==V(a)?{[s]:n}:{}}})),1}))?t:{}},l=()=>{const t=P(e.getValuesSchemaJson());return $t(t)&&e.forEachValue(((e,l)=>{t[e]={[r]:B(l)}})),t},a=e=>Gt(t(),l(),e),n=async e=>{const t=["d.ts","ts","d.ts","tsx"];let l;try{l=(await import("prettier")).format}catch(e){l=e=>e}return k(a(e),((e,a)=>qe(l(e,{...Jt,filepath:"_."+t[a]}))))};return st({getStoreStats:t=>{let l=0,a=0,n=0;const o={};return e.forEachTable(((e,r)=>{l++;let s=0,d=0;const c={};r(((e,l)=>{s++;let a=0;l((()=>a++)),d+=a,t&&(c[e]={rowCells:a})})),a+=s,n+=d,t&&(o[e]={tableRows:s,tableCells:d,rows:c})})),{totalTables:l,totalRows:a,totalCells:n,totalValues:V(e.getValueIds()),jsonLength:Ke(e.getJson()),...t?{detail:{tables:o}}:{}}},getStoreTablesSchema:t,getStoreValuesSchema:l,getStoreApi:a,getPrettyStoreApi:n,getStore:()=>e})}));e.createTools=Bt},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBaseTools={});
