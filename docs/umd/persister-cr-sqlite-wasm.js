var a,t;a=this,t=function(a){"use strict";const t=a=>typeof a,e="tinybase",s=",",n=t(""),i=(a,t="")=>a.join(t),r=(a,t)=>a.map(t),o=a=>a.length,c=a=>0==o(a),l=(a,t)=>a.filter(t),y=(a,t,e)=>a.slice(t,e),u=(a,...t)=>a.push(...t),d=Promise,w=JSON.parse,E=(a,t)=>a instanceof t,p=a=>null==a,v=(a,t,e)=>p(a)?e?.():t(a),f=a=>t(a)==n,m=async a=>d.all(a),T=Object,A=T.keys,h=T.freeze,L=(a=[])=>T.fromEntries(a),S=(...a)=>T.assign({},...a),C=(a,t)=>(delete a[t],a),N=(a,t)=>r(T.entries(a),(([a,e])=>t(e,a))),O=a=>T.values(a),R=a=>o(A(a)),b=a=>(a=>E(a,T)&&a.constructor==T)(a)&&0==R(a),g=(a,t)=>a?.has(t)??!1,I=a=>[...a?.values()??[]],_=(a,t)=>a?.delete(t),D=a=>new Map(a),$=(a,t)=>a?.get(t),M=(a,t)=>r([...a?.entries()??[]],(([a,e])=>t(e,a))),P=(a,t,e)=>p(e)?(_(a,t),a):a?.set(t,e),F=(a,t,e,s=P)=>(N(t,((t,s)=>e(a,s,t))),((a,t)=>{((a,t)=>{a?.forEach(t)})(a,((a,e)=>t(e)))})(a,(e=>((a,t)=>!p(((a,t)=>v(a,(a=>a[t])))(a,t)))(t,e)?0:s(a,e))),a),B="_id",j=a=>`"${a.replace(/"/g,'""')}"`,x=a=>new Set(Array.isArray(a)||p(a)?a:[a]),q="SELECT*FROM",W="FROM pragma_table_",k="WHERE",J=k+" schema='main'AND type='table'AND name!='sqlite_schema'",U=a=>{const t=D(),e=(a,e)=>!p($($(t,a),e)),n=async(e,n,l,y,d)=>{const w=x();N(d??{},(a=>r(A(a),(a=>{return t=w,e=a,t?.add(e);var t,e}))));const E=I(w);if(c(E)&&g(t,e)&&y)return await a("DROP TABLE"+j(e)),void P(t,e);if(c(E)||g(t,e)){const s=$(t,e),i=x((p=s,[...p?.keys()??[]]));await m([...r(E,(async t=>{_(i,t)||(await a(`ALTER TABLE${j(e)}ADD${j(t)}`),P(s,t,""))})),...l?r(I(i),(async t=>{t!=n&&(await a(`ALTER TABLE${j(e)}DROP${j(t)}`),P(s,t))})):[]])}else await a(`CREATE TABLE${j(e)}(${j(n)} PRIMARY KEY ON CONFLICT REPLACE${i(r(E,(a=>s+j(a))))});`),P(t,e,D([[n,""],...r(E,(a=>[a,""]))]));var p;if(c(E))await a("DELETE FROM"+j(e));else{const t=[],c=[],l=[];N(d,((a,e)=>{var s;u(t,`(?${s=o(E),",?".repeat(s)})`),u(c,e,...r(E,(t=>a[t]))),u(l,e)})),await a("INSERT INTO"+j(e)+"("+j(n)+i(r(E,(a=>s+j(a))))+")VALUES"+i(t,s),c),await a("DELETE FROM"+j(e)+k+j(n)+"NOT IN("+i(r(l,(()=>"?")),s)+")",l)}};return[async()=>F(t,L(await m(r(await a("SELECT name "+W+"list "+J),(async({name:t})=>[t,L(r(await a("SELECT name,type "+W+"info(?)",[t]),(({name:a,type:t})=>[a,t])))])))),((a,e,s)=>{return P(t,e,F((r=D,g(n=t,i=e)||P(n,i,r()),$(n,i)),s,((a,t,e)=>{e!=$(a,t)&&P(a,t,e)}),((a,t)=>P(a,t))));var n,i,r}),((a,e)=>P(t,e))),async(t,s)=>{const n=e(t,s)?await a(q+j(t)+k+j(s)+"=?",["_"]):[];return c(n)?null:C(n[0],s)},async(a,t,e,s)=>await n(a,t,!0,!0,{[e]:s}),async(t,s)=>e(t,s)?L(l(r(await a(q+j(t)),(a=>[a[s],C(a,s)])),(([a,t])=>!p(a)&&!b(t)))):{},n]},Y=(a,t,e,s,n)=>{let i,r,o,c=0,l=0,y=0;const d=[],w=async a=>{2!=c&&(c=1,await a(),c=0)},E={load:async(e,s)=>(await w((async()=>{try{a.setContent(await t())}catch{a.setContent([e,s])}})),E),startAutoLoad:async(e={},n={})=>(E.stopAutoLoad(),await E.load(e,n),y=1,o=s((async(e,s)=>{await w((async()=>{if(s)a.setTransactionChanges(s());else try{a.setContent(e?.()??await t())}catch{}}))})),E),stopAutoLoad:()=>(y&&(n(o),o=void 0,y=0),E),save:async t=>(await E.schedule((async()=>{if(1!=c){c=2;try{await e(a.getContent,t)}catch{}c=0}})),E),startAutoSave:async()=>(await E.stopAutoSave().save(),i=a.addDidFinishTransactionListener(((a,t)=>{const e=t();E.save((()=>e))})),E),stopAutoSave:()=>(v(i,a.delListener),E),schedule:async(...a)=>(u(d,...a),await(async()=>{if(!l){for(l=1;!p((a=d,r=a.shift()));)try{await r()}catch{}l=0}var a})(),E),getStore:()=>a,destroy:()=>E.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return h(E)},z="store",H=(a,t,s,n,{storeTableName:i=e})=>{const[r,o,c]=U(t),l=Y(a,(async()=>(await r(),w((await o(i,B)??{})[z]))),(async a=>l.schedule(r,(async()=>{var t;await c(i,B,"_",{[z]:(t=a(),JSON.stringify(t,((a,t)=>{return E(t,Map)?(e=(a,[t,e])=>(a[t]=e,a),s={},[...t].reduce(e,s)):t;var e,s})))})}))),s,n);return l},K="rowIdColumnName",V="tableId",G="tableName",Q={load:0,save:0,[G]:e+"_values"},X=(a,t,e,s)=>{const n=D();return N(a,((a,i)=>{const r=y(O(S(t,f(a)?{[e]:a}:a)),0,R(t));p(r[0])||s(i,r[0])||P(n,i,r)})),n},Z=(a,t,e,s,n)=>{const[i,r,[o,c,u]]=(({tables:{load:a={},save:t={}}={},values:e={}})=>{const s=y(O(S(Q,e)),0,R(Q)),n=s[2];return[X(a,{[V]:null,[K]:B},V,(a=>a==n)),X(t,{[G]:null,[K]:B,deleteEmptyColumns:0,deleteEmptyTable:0},G,((a,t)=>t==n)),s]})(n),[d,w,E,v,f]=U(t),T=Y(a,(async()=>{await d();const a=await(async()=>L(l(await m(M(i,(async([a,t],e)=>[a,await v(e,t)]))),(a=>!b(a[1])))))(),t=await(async()=>o?await w(u,B):{})();return b(a)&&p(t)?void 0:[a,t]}),(async a=>{const[t,e]=a();T.schedule(d,...(a=>M(r,(([t,e,s,n],i)=>async()=>await f(t,e,s,n,a[i]))))(t),(a=>c?async()=>await E(u,B,"_",a):null)(e))}),e,s);return T},aa="json",ta="autoLoadIntervalSeconds",ea={mode:aa,[ta]:1},sa="pragma ",na="data_version",ia="schema_version",ra=(a,t,e,s,n)=>{const i=S(ea,f(t)?{storeTableName:t}:t??{});let r,o;return(i.mode==aa?H:Z)(a,e,(a=>[setInterval((async()=>{try{const t=(await e(sa+na))[0][na],s=(await e(sa+ia))[0][ia];t==(r??=t)&&s==(o??=s)||(a(),r=t,o=s)}catch{}}),1e3*i[ta]),s(a)]),(([a,t])=>{clearInterval(a),r=o=null,n(t)}),i)};a.createCrSqliteWasmPersister=(a,t,e)=>ra(a,e,(async(a,e=[])=>await t.execO(a,e)),(a=>t.onUpdate((()=>a()))),(a=>a()))},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((a="undefined"!=typeof globalThis?globalThis:a||self).TinyBasePersisterCrSqliteWasm={});
