var t,e;t=this,e=function(t){"use strict";const e=t=>typeof t,a=e(""),n=t=>null==t,s=(t,e,a)=>n(t)?a?.():e(t),o=Object,c=t=>o.getPrototypeOf(t),r=o.entries,i=o.keys,d=o.freeze,y=(t,e)=>s(t,(t=>t[e])),u=(t,e)=>e in t,l=(t,e)=>(delete t[e],t),p=(t,e)=>((t,e)=>t.map(e))(r(t),(([t,a])=>e(a,t))),g=t=>i(t).length,h=t=>(t=>!n(t)&&s(c(t),(t=>t==o.prototype||n(c(t))),(()=>!0)))(t)&&0==g(t),f=t=>new Map(t),v=(t,e)=>t?.get(e),w=(t,e,a)=>{return n(a)?(s=t,o=e,s?.delete(o),t):t?.set(e,a);var s,o},A=(t,e,a)=>{var n,s;return n=t,s=e,n?.has(s)||w(t,e,a()),v(t,e)},C=f(),b=f(),L=(t,e)=>[t[e].t,t[e].v],m=(t,e,a,s)=>{const o=n(e)?t:((t,e,a)=>(u(t,e)||(t[e]={}),t[e]))(t,e);let c;return p(a,((t,e)=>{s(o,e,t)&&(c=1)})),p(o,((t,e)=>{u(a,e)||(l(o,e),c=1)})),!n(e)&&h(o)&&l(t,e),c};t.createAutomergePersister=(t,o,c="tinybase",r)=>(o.change((t=>t[c]={})),((t,o,c,r,i,y,u,[l,p]=[],g=[])=>{let f,L,m,S=0,T=0;A(C,g,(()=>0)),A(b,g,(()=>[]));const x=(u?t.getMergeableContent:null)??t.getContent,M=t.getTransactionChanges,P=async t=>(2!=S&&(S=1,await j.schedule((async()=>{await t(),S=0}))),j),j={load:async(n,s)=>await P((async()=>{try{const n=await o();(u&&(t=>e(t)==a)(n[0])?t.applyMergeableChanges:t.setContent)(n)}catch{t.setContent([n,s])}})),startAutoLoad:async(e={},a={})=>(j.stopAutoLoad(),await j.load(e,a),T=1,m=r((async(e,a)=>{if(a){const e=a();await P((async()=>t.applyChanges(e)))}else await P((async()=>{try{t.setContent(e?.()??await o())}catch(t){y?.(t)}}))})),j),stopAutoLoad:()=>(T&&(i(m),m=void 0,T=0),j),save:async t=>(1!=S&&(S=2,await j.schedule((async()=>{try{await c(x,t)}catch(t){y?.(t)}S=0}))),j),startAutoSave:async()=>(await j.stopAutoSave().save(),f=t.addDidFinishTransactionListener((()=>{const[t,e]=M();h(t)&&h(e)||j.save((()=>[t,e]))})),j),stopAutoSave:()=>(s(f,t.delListener),f=void 0,j),schedule:async(...t)=>(((t,...e)=>{t.push(...e)})(v(b,g),...t),await(async()=>{if(!v(C,g)){for(w(C,g,1);!n((t=v(b,g),L=t.shift()));)try{await L()}catch(t){y?.(t)}w(C,g,0)}var t})(),j),getStore:()=>t,destroy:()=>j.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return l&&(j[l]=()=>p),d(j)})(t,(async()=>{const t=await o.doc();return 2==g(t[c])?L(t,c):void 0}),(async(t,e)=>o.change((a=>((t,e,a,o)=>{((t,e)=>{h(t[e])&&(t[e]={t:{},v:{}})})(t,e);const[c,r]=L(t,e),i=()=>{d=1};let d=1;if(s(o?.(),(([t,e])=>{d=0,p(t,((t,e)=>d?0:n(t)?l(c,e):s(c[e],(e=>p(t,((t,a)=>d?0:n(t)?l(e,a):s(y(e,a),(e=>p(t,((t,a)=>n(t)?l(e,a):e[a]=t))),i)))),i))),p(e,((t,e)=>d?0:n(t)?l(r,e):r[e]=t))})),d){const[t,e]=a();m(c,void 0,t,((t,e,a)=>m(c,e,a,((t,e,a)=>m(t,e,a,((t,e,a)=>{if(y(t,e)!==a)return t[e]=a,1})))))),m(r,void 0,e,((t,e,a)=>{y(r,e)!==a&&(r[e]=a)}))}})(a,c,t,e)))),(t=>{const e=({doc:e})=>t((()=>L(e,c)));return o.on("change",e),e}),(t=>{o.removeListener("change",t)}),r,!1,["getDocHandle",o]))},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterAutomerge={});
