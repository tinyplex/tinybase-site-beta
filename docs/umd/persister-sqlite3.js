var a,t;a=this,t=function(a){"use strict";const t=a=>typeof a,e="tinybase",s=",",n=t(""),i=(a,t="")=>a.join(t),o=(a,t)=>a.map(t),r=a=>a.length,c=a=>0==r(a),l=(a,t)=>a.filter(t),y=(a,t,e)=>a.slice(t,e),u=(a,...t)=>a.push(...t),d=Promise,w=JSON.parse,E=(a,t)=>a instanceof t,f=a=>null==a,p=(a,t,e)=>f(a)?e?.():t(a),v=a=>t(a)==n,m=async a=>d.all(a),T=Object,h=T.keys,A=T.freeze,L=(a=[])=>T.fromEntries(a),S=(...a)=>T.assign({},...a),g=(a,t)=>(delete a[t],a),C=(a,t)=>o(T.entries(a),(([a,e])=>t(e,a))),N=a=>T.values(a),R=a=>r(h(a)),b=a=>(a=>E(a,T)&&a.constructor==T)(a)&&0==R(a),O=(a,t)=>a?.has(t)??!1,I=a=>[...a?.values()??[]],_=(a,t)=>a?.delete(t),D=a=>new Map(a),$=(a,t)=>a?.get(t),M=(a,t)=>o([...a?.entries()??[]],(([a,e])=>t(e,a))),P=(a,t,e)=>f(e)?(_(a,t),a):a?.set(t,e),F=(a,t,e,s=P)=>(C(t,((t,s)=>e(a,s,t))),((a,t)=>{((a,t)=>{a?.forEach(t)})(a,((a,e)=>t(e)))})(a,(e=>((a,t)=>!f(((a,t)=>p(a,(a=>a[t])))(a,t)))(t,e)?0:s(a,e))),a),B="_id",j=a=>`"${a.replace(/"/g,'""')}"`,q=a=>new Set(Array.isArray(a)||f(a)?a:[a]),x="SELECT*FROM",k="FROM pragma_table_",J="WHERE",Y=J+" schema='main'AND type='table'AND name!='sqlite_schema'",z=a=>{const t=D(),e=(a,e)=>!f($($(t,a),e)),n=async(e,n,l,y,d)=>{const w=q();C(d??{},(a=>o(h(a),(a=>{return t=w,e=a,t?.add(e);var t,e}))));const E=I(w);if(c(E)&&O(t,e)&&y)return await a("DROP TABLE"+j(e)),void P(t,e);if(c(E)||O(t,e)){const s=$(t,e),i=q((f=s,[...f?.keys()??[]]));await m([...o(E,(async t=>{_(i,t)||(await a(`ALTER TABLE${j(e)}ADD${j(t)}`),P(s,t,""))})),...l?o(I(i),(async t=>{t!=n&&(await a(`ALTER TABLE${j(e)}DROP${j(t)}`),P(s,t))})):[]])}else await a(`CREATE TABLE${j(e)}(${j(n)} PRIMARY KEY ON CONFLICT REPLACE${i(o(E,(a=>s+j(a))))});`),P(t,e,D([[n,""],...o(E,(a=>[a,""]))]));var f;if(c(E))await a("DELETE FROM"+j(e));else{const t=[],c=[],l=[];C(d,((a,e)=>{var s;u(t,`(?${s=r(E),",?".repeat(s)})`),u(c,e,...o(E,(t=>a[t]))),u(l,e)})),await a("INSERT INTO"+j(e)+"("+j(n)+i(o(E,(a=>s+j(a))))+")VALUES"+i(t,s),c),await a("DELETE FROM"+j(e)+J+j(n)+"NOT IN("+i(o(l,(()=>"?")),s)+")",l)}};return[async()=>F(t,L(await m(o(await a("SELECT name "+k+"list "+Y),(async({name:t})=>[t,L(o(await a("SELECT name,type "+k+"info(?)",[t]),(({name:a,type:t})=>[a,t])))])))),((a,e,s)=>{return P(t,e,F((o=D,O(n=t,i=e)||P(n,i,o()),$(n,i)),s,((a,t,e)=>{e!=$(a,t)&&P(a,t,e)}),((a,t)=>P(a,t))));var n,i,o}),((a,e)=>P(t,e))),async(t,s)=>{const n=e(t,s)?await a(x+j(t)+J+j(s)+"=?",["_"]):[];return c(n)?null:g(n[0],s)},async(a,t,e,s)=>await n(a,t,!0,!0,{[e]:s}),async(t,s)=>e(t,s)?L(l(o(await a(x+j(t)),(a=>[a[s],g(a,s)])),(([a,t])=>!f(a)&&!b(t)))):null,n]},H=(a,t,e,s,n)=>{let i,o,r,c=0,l=0,y=0;const d=[],w=async a=>{2!=c&&(c=1,await a(),c=0)},E={load:async(e={},s={})=>(await w((async()=>{try{a.setContent(await t())}catch{a.setContent([e,s])}})),E),startAutoLoad:async(e={},n={})=>(E.stopAutoLoad(),await E.load(e,n),y=1,r=s((async(e,s)=>{await w((async()=>{if(s)a.setTransactionChanges(s());else try{a.setContent(e?.()??await t())}catch{}}))})),E),stopAutoLoad:()=>(y&&(n(r),r=void 0,y=0),E),save:async t=>(await E.schedule((async()=>{if(1!=c){c=2;try{await e(a.getContent,t)}catch{}c=0}})),E),startAutoSave:async()=>(await E.stopAutoSave().save(),i=a.addDidFinishTransactionListener(((a,t)=>{const e=t();E.save((()=>e))})),E),stopAutoSave:()=>(p(i,a.delListener),E),schedule:async(...a)=>(u(d,...a),await(async()=>{if(!l){for(l=1;!f((a=d,o=a.shift()));)try{await o()}catch{}l=0}var a})(),E),getStore:()=>a,destroy:()=>E.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return A(E)},K="store",U=(a,t,s,n,{storeTableName:i=e})=>{const[o,r,c]=z(t),l=H(a,(async()=>(await o(),w((await r(i,B)??{})[K]))),(async a=>l.schedule(o,(async()=>{var t;await c(i,B,"_",{[K]:(t=a(),JSON.stringify(t,((a,t)=>{return E(t,Map)?(e=(a,[t,e])=>(a[t]=e,a),s={},[...t].reduce(e,s)):t;var e,s})))})}))),s,n);return l},V="rowIdColumnName",W="tableId",G="tableName",Q={load:0,save:0,[G]:e+"_values"},X=(a,t,e,s)=>{const n=D();return C(a,((a,i)=>{const o=y(N(S(t,v(a)?{[e]:a}:a)),0,R(t));f(o[0])||s(i,o[0])||P(n,i,o)})),n},Z=(a,t,e,s,n)=>{const[i,o,[r,c,u]]=(({tables:{load:a={},save:t={}}={},values:e={}})=>{const s=y(N(S(Q,e)),0,R(Q)),n=s[2];return[X(a,{[W]:null,[V]:B},W,(a=>a==n)),X(t,{[G]:null,[V]:B,deleteEmptyColumns:0,deleteEmptyTable:0},G,((a,t)=>t==n)),s]})(n),[d,w,E,p,v]=z(t),T=H(a,(async()=>{await d();const a=await(async()=>L(l(await m(M(i,(async([a,t],e)=>[a,await p(e,t)]))),(a=>a[1]))))(),t=await(async()=>r?await w(u,B):{})();return b(a)&&f(t)?void 0:[a,t]}),(async a=>{const[t,e]=a();T.schedule(d,...(a=>M(o,(([t,e,s,n],i)=>async()=>await v(t,e,s,n,a[i]))))(t),(a=>c?async()=>await E(u,B,"_",a):null)(e))}),e,s);return T},aa="json",ta="autoLoadIntervalSeconds",ea={mode:aa,[ta]:1},sa="pragma ",na="data_version",ia="schema_version",oa=(a,t,e,s,n)=>{const i=S(ea,v(t)?{storeTableName:t}:t??{});let o,r;return(i.mode==aa?U:Z)(a,e,(a=>[setInterval((async()=>{try{const t=(await e(sa+na))[0][na],s=(await e(sa+ia))[0][ia];t==(o??=t)&&s==(r??=s)||(a(),o=t,r=s)}catch{}}),1e3*i[ta]),s(a)]),(([a,t])=>{clearInterval(a),o=r=null,n(t)}),i)},ra="change";a.createSqlite3Persister=(a,t,e)=>oa(a,e,((a,e=[])=>new d(((s,n)=>t.all(a,e,((a,t)=>a?n(a):s(t.map((a=>({...a}))))))))),(a=>{const e=()=>a();return t.on(ra,e),e}),(a=>t.off(ra,a)))},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((a="undefined"!=typeof globalThis?globalThis:a||self).TinyBasePersisterSqlite3={});
